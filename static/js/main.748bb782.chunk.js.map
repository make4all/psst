{"version":3,"sources":["sonification/output/Speech.ts","sonification/handler/SlopeParityHandler.ts","sonification/handler/FilterRangeHandler.ts","sonification/output/DatumOutput.ts","sonification/output/SonifyFixedDuration.ts","sonification/OutputConstants.ts","sonification/handler/RunningExtremaHandler.ts","sonification/output/NoiseSonify.ts","DataManager.ts","views/ImportView.tsx","views/DataView.tsx","views/demos/DemoSimple.tsx","views/demos/DemoHighlightRegion.tsx","views/demos/DemoSpeakRange.tsx","sonification/handler/NotificationHandler.ts","views/demos/DemoFileOutput.tsx","views/demos/DemoSlopeParityV1.tsx","views/demos/DemoSlopeParityV2.tsx","pages/Demo.tsx","views/demos/DemoRunningExtrema.tsx","pages/Index.tsx","index.jsx","sonification/Datum.ts","sonification/DataSink.ts","sonification/OutputEngine.ts","sonification/output/NoteSonify.ts","sonification/stat/Statistic.ts","sonification/stat/RangeEndExpander.ts","sonification/handler/ScaleHandler.ts","sonification/handler/NoteHandler.ts","sonification/handler/DataHandler.ts","sonification/output/Sonify.ts","sonification/output/FileOutput.ts"],"names":["Speech","lang","volume","rate","voice","polite","_speechSynthesis","_utterance","_volume","playing","_polite","window","speechSynthesis","SpeechSynthesisUtterance","getVoices","debugStatic","SonificationLoggingLevel","DEBUG","this","value","datum","console","log","text","toString","pending","speaking","cancel","speak","resume","onend","DatumOutput","level","message","getSonificationLoggingLevel","SlopeParityHandler","direction","output","_prevSlope","_prevPoint","_direction","sink$","pipe","filter","val","Datum","slope","prevPoint","Math","sign","prevSlope","DataHandler","FilterRangeHandler","domain","_domain","num","insideDomain","state","OutputStateChange","Undefined","subscription","stream$","tap","Play","Stop","start","Pause","stop","pause","Swap","Error","debug","subscribe","unsubscribe","lastValueFrom","Subject","watch","source","tag","SonifyFixedDuration","audioNode","duration","pan","startTime","undefined","timePlayed","audioCtx","currentTime","timeLeft","extend","create","onended","resetAudioNode","outputNode","Sonify","SonificationLevel","GrowthDirection","sonificationLoggingLevel","RunningExtremaHandler","_extrema","Number","MIN_VALUE","MAX_VALUE","NoiseSonify","timeAdd","noiseNode","buffer","fillBuffer","length","noiseBufferSize","sampleRate","createBuffer","bufferData","getChannelData","i","random","createBufferSource","createBiquadFilter","type","frequency","connect","gainNode","DataManager","_listeners","table","url","trim","fetch","then","res","instance","loadDataFromText","tabNum","lineNum","charAt","delimiter","header","aq","columns","handleDataChange","file","listener","push","splice","EXAMPLE_LIST","fileName","displayName","ImportView","props","_selectExample","_textArea","_inputFile","_textField","_handleClickContinue","event","importType","current","getInstance","input","querySelector","loadDataFromUrl","_handleFileChange","target","files","loadDataFromFile","_handleExampleChange","exampleValue","setState","_handleImportTypeChange","React","createRef","inputElement","headerText","bodyText","continueButton","Button","variant","sx","mt","mr","onClick","FormControl","InputLabel","htmlFor","id","NativeSelect","ref","placeholder","onChange","map","e","TextareaAutosize","style","width","maxHeight","overflow","minRows","Box","component","p","border","Input","display","TextField","label","Grid","container","spacing","item","xs","sm","md","ToggleButtonGroup","orientation","exclusive","ToggleButton","ListAlt","textTransform","marginLeft","textAlign","maxWidth","lineHeight","ContentPaste","UploadFile","Link","Stack","Typography","color","Component","DataView","handleDataUpdate","columnNames","c","field","headerName","renderHeader","params","rows","objects","o","Object","assign","addListener","loaded","height","DemoSimple","data","sink","delaySink","onPause","OutputEngine","next","onPlay","initializeSink","dataCopy","data$","of","timer$","timer","source$","zip","time","complete","setStream","addDataHandler","NoteHandler","reduce","prev","curr","NoteSonify","initializeDelaySink","addSink","deleteSink","DemoHighlightRegion","_handleValueChange","which","minValue","maxValue","dataSummary","min","max","isNaN","parseFloat","prevProps","DemoSpeakRange","NotificationHandler","interestPoints","_interestPoints","includes","isInterestPoint","DemoFileOutput","notifier","_buffer","values","split","targets","numb","targetValues","arrayBuffer","catch","error","mb","FileOutput","DemoSlopeParityV1","slopeHandler","DemoSlopeParityV2","increasingTracker","decreasingTracker","_increasingBuffer","_decreasingBuffer","DEMO_VIEW_MAP","simple","highlightRegion","speechHighlight","fileOutput","slopeParityV1","slopeParityV2","runningExtrema","minimumTracker","maximumTracker","demoViewRef","Demo","_handleDataChange","columnList","exampleRow","object","column","columnSelected","_computeDataSummary","rollup","mean","op","median","count","_handlePlayButton","outputEngineInstance","outputState","array","demoView","_handlePlaybackStateChanged","playbackLabel","_handleDemoViewValueChange","demoViewValue","_handleColumnSelectChange","DemoComponent","marginTop","Index","name","opt","to","Jacdac","lazy","Dashboard","MicrobitController","ReactDOM","render","path","element","fallback","document","getElementById","sinkId","d3","DataSink","description","overrideDatum","_description","_dataHandlers","Array","dataHandler","observable","setupSubscription","statedatum$","spy","sinks","Map","show","newId","forEach","key","get","assert","getUniqueId","has","set","delete","x","getSink","filteredState$","shareReplay","combined$","merge","BehaviorSubject","oscillator","createOscillator","isAudioPlaying","Statistic","singlePoint$","RangeEndExpander","acc","Min","distinctUntilChanged","ScaleHandler","conversionFunction","targetRange","range","_conversionFunction","NaN","Max","melConversion","positiveVal","exp","_outputs","addOutput","setupOutputSubscription","outputStream$","_stereoPannerNode","_gainNode","_outputNode","_audioCtx","createGain","createStereoPanner","stereoPannerNode","disconnect","destination","suspend","AudioContext","decodeAudioData","slice"],"mappings":"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","file":"static/js/main.748bb782.chunk.js","sourcesContent":["import { Datum } from '../Datum'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from '../OutputConstants';\nimport { DatumOutput } from './DatumOutput'\n\nconst DEBUG = true;\n\n/**\n * Class for sonifying data point as speech.\n */\nexport class Speech extends DatumOutput {\n    private _speechSynthesis : SpeechSynthesis\n    private _utterance : SpeechSynthesisUtterance\n    private _volume: number;\n    private playing: boolean;\n    \n    private _polite: boolean;\n    public get polite(): boolean  {\n        return this._polite\n    }\n\n    public set polite(value: boolean) {\n        this._polite = value\n    }\n\n    // construct the utterance and set its properties\n    public constructor(lang?: string, volume?: number, rate?: number, voice?: SpeechSynthesisVoice, polite: boolean = false) {\n        super()\n        this._speechSynthesis = window.speechSynthesis;\n        this._utterance = new SpeechSynthesisUtterance()\n        this._utterance.rate = rate? rate : 10 // rate is 0.1-10\n        this._volume = volume? volume : 1 // volume is 0-1\n        if (lang) this._utterance.lang = lang\n        if (voice) this._utterance.voice = voice\n        else {\n            this._utterance.voice = this._speechSynthesis.getVoices()[0];\n        }\n         this._polite = polite\n\n        this.playing = false;\n        debugStatic (SonificationLoggingLevel.DEBUG, \"initialized\")\n    }\n\n    /**\n     * Output the datum as speech\n     */\n    protected output(datum: Datum) {\n        console.log(\"enter speech output\")\n        if (!this.playing) return\n        super.output(datum)\n        this._utterance.text = datum.value.toString()\n        if((this._speechSynthesis.pending || this._speechSynthesis.speaking) && !this.polite) {\n            this._speechSynthesis.cancel()\n            console.log(\"bout to interrupt\")\n        }\n        this._speechSynthesis.speak(this._utterance)\n        console.log(\"spoken!\")\n    }\n\n    // Start speaking\n    public start(): void {\n        this._utterance.volume = this._volume;\n        this._speechSynthesis.resume(); // always resume before speaking. There is a bug on Web Speech that if you pause for more than 15 seconds, speech fails quietly.\n        // stop any future utterances\n        if (this._speechSynthesis.pending) {\n            this._speechSynthesis.cancel();\n        }\n        // start current utterance\n        this.playing = true\n\n        this._utterance.onend = () => { this._utterance.text = \"\"} // natural end\n        super.start();\n    }\n\n    // Pause speech if playing.\n    public pause(): void {\n        this._utterance.volume = 0;\n        this._speechSynthesis.cancel();\n        this.playing = false\n        super.pause();\n    }\n\n    // Resume speech if paused.\n    public resume(): void {\n        this.playing = true\n        this._utterance.volume = this._volume;\n        this._speechSynthesis.resume();\n    }\n\n    // Stop speech.\n    public stop(): void {\n        if (this._speechSynthesis.pending) {\n            this._speechSynthesis.cancel();\n        }\n        this.playing = false\n    }\n\n    public toString() : string {\n        return `Speech`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nimport { Observable, tap } from 'rxjs';\n\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } else console.log('debug message dumped')\n    }\n}","import { filter, Observable, tap } from 'rxjs'\nimport { DatumOutput } from '../output/DatumOutput'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from '../OutputConstants'\nimport { DataHandler } from './DataHandler'\n\nconst DEBUG = true\n\n/**\n * A DataHandler that tracks the slope of the data\n * @todo change this to take a function that decides how to filter?\n */\nexport class SlopeParityHandler extends DataHandler {\n    /**\n     * The slope between the previous two points.\n     */\n    private _prevSlope: number\n    public get prevSlope(): number {\n        return this._prevSlope\n    }\n    public set prevSlope(value: number) {\n        this._prevSlope = value\n    }\n\n    /**\n     * The previous data point, used to calculate current slope.\n     */\n    private _prevPoint: number\n    public get prevPoint(): number {\n        return this._prevPoint;\n    }\n    public set prevPoint(value: number) {\n        this._prevPoint = value\n    }\n\n    /**\n     * Direction to be tracked and notified for.\n     */\n    private _direction: number\n    public get direction(): number {\n        return this._direction\n    }\n    public set direction(value: number) {\n        this._direction = value\n    }\n\n    /**\n     * Constructor\n     *\n     * @param sink. DataSink that is providing data to this Handler.\n     * @param output. Optional output for this data\n     * @param direction. -1 for decreasing, 1 for increasing. Defaults to 0 if not provided.\n     */\n    constructor(direction?: number, output?: DatumOutput) {\n        super(output)\n        this._prevPoint = 0\n        this._prevSlope = 0\n        if (direction) {\n            this._direction = direction\n        } else {\n            this._direction = 0\n        }\n    }\n\n    /**\n     * Set up a subscription so we are notified about events\n     * Override this if the data needs to be modified in some way\n     *\n     * @param sink The sink that is producing data for us\n     */\n     public setupSubscription(sink$: Observable<OutputStateChange | Datum>) {\n        debugStatic (SonificationLoggingLevel.DEBUG, `setting up subscription for ${this} ${sink$}`)\n        super.setupSubscription(\n            sink$.pipe(\n                filter((val) => {\n                    if (val instanceof Datum){\n                        let slope = val.value - this.prevPoint\n                        this.prevPoint = val.value // no matter what, we'll need the prev point to calculate the slope\n                        if (this.direction == 0) {\n                            console.log(\"direction 0\")\n                            if (Math.sign(slope) != Math.sign(this.prevSlope)) {\n                                if (DEBUG) console.log('direction of slope changed')\n                                this.prevSlope = slope\n                                return true\n                            }\n                            return false\n                        } else {\n                            if (Math.sign(slope) == this.direction) {\n                                if (Math.sign(slope) != Math.sign(this.prevSlope)) {\n                                    this.prevSlope = slope\n                                    return true\n                                } else { // slope did not change direction\n                                    this.prevSlope = slope\n                                    return false\n                                }\n                            }\n                            this.prevSlope = slope\n                            return false\n                        }\n                    }\n                    else return true\n                }),\n            ),\n        )\n    }\n\n    /**\n     * @returns A string describing this class including its range.\n     */\n    public toString(): string {\n        return `SlopeParityHandler`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nimport { Datum } from '../Datum'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (false) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } else console.log('debug message dumped')\n    }\n}\n","import { filter, Observable, tap } from 'rxjs'\nimport { DatumOutput } from '../output/DatumOutput'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from '../OutputConstants'\nimport { DataHandler } from './DataHandler'\n\nconst DEBUG = false\n\n/**\n * A DataHandler that filters out things which are not betwen min and max (inclusive)\n * @todo change this to take a function that decides how to filter?\n */\nexport class FilterRangeHandler extends DataHandler {\n    /**\n     * The domain to accept points within. Defaults to 0,0 if not defined in constructor\n     */\n    private _domain: [number, number]\n    public get domain(): [number, number] {\n        return this._domain\n\n    }\n    public set domain(value: [number, number]) {\n        this._domain = value\n    }\n\n    public insideDomain(num: number): boolean {\n        debugStatic(SonificationLoggingLevel.DEBUG, `checking if ${num} is inside ${this.domain}`)\n        return num >= this.domain[0] && num <= this.domain[1]\n    }\n\n    /**\n     * Constructor\n     *\n     * @param sink. DataSink that is providing data to this Handler.\n     * @param output. Optional output for this data\n     * @param domain [min, max]. Defaults to 0, 0 if not provided\n     */\n    constructor(domain?: [number, number], output?: DatumOutput) {\n        super(output)\n        debugStatic(SonificationLoggingLevel.DEBUG, \"setting up filter range handeler\")\n        if (domain){\n            debugStatic(SonificationLoggingLevel.DEBUG, `setting up filter range handeler with domain ${domain}`)\n            this._domain = domain\n\n        } \n\n        else this._domain = [0, 0]\n    }\n\n    /**\n     * Set up a subscription so we are notified about events\n     * Override this if the data needs to be modified in some way\n     *\n     * @param sink The sink that is producing data for us\n     */\n    public setupSubscription(sink$: Observable<OutputStateChange | Datum>) {\n        debugStatic (SonificationLoggingLevel.DEBUG, `setting up subscription for ${this} ${sink$}`)\n        super.setupSubscription(\n            sink$.pipe(\n                filter((val) => {\n                    if (val instanceof Datum){\n                        debugStatic(SonificationLoggingLevel.DEBUG, `checking if ${val} is inside ${this.domain}`)\n                        return this.insideDomain(val.value)\n                    }\n                    else return true\n                }),\n            ),\n        )\n    }\n\n    /**\n     * @returns A string describing this class including its range.\n     */\n    public toString(): string {\n        return `FilterRangeHandler: Keeping only data in ${this.domain[0]},${this.domain[1]}`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nimport { Datum } from '../Datum'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        }// else console.log('debug message dumped')\n\n    }\n}\n\n\n","import { lastValueFrom, Observable, Subject, Subscription, tap } from 'rxjs'\nimport { Datum } from '../Datum'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from '../OutputConstants'\n\nconst DEBUG = false\n\n/**\n * Base class for outputing information about a single datum. Must be subclassed to be fully defined\n * @field datum The raw data used to generate this sonification type\n */\nexport abstract class DatumOutput extends Subject<OutputStateChange | Datum> {\n    /**\n     * Are we playing right now?\n     */\n    private state = OutputStateChange.Undefined\n\n\n    private subscription?: Subscription\n\n    /**\n     * Subscribe to the handler (override to modify or filter the stream in some way)\n     *\n     * @param stream$ An Output's stream of Datum comes from a DataHandlar\n     */\n    public setupSubscription(stream$: Observable<OutputStateChange | Datum>) {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'setting up output subscription')\n        this.subscription = stream$\n            .pipe(\n                tap((val) => {\n                    if (val instanceof Datum) {\n                        debugStatic(SonificationLoggingLevel.DEBUG, `datum is  ${val}`)\n                        if (this.state == OutputStateChange.Play) {\n                            this.output(val)\n                        }\n                    } else {\n                        debugStatic(\n                            SonificationLoggingLevel.DEBUG,\n                            `setting up state ${OutputStateChange[val]}: was ${OutputStateChange[this.state]}`,\n                        )\n                        switch (val as OutputStateChange) {\n                            case OutputStateChange.Play:\n                                if (this.state == OutputStateChange.Stop || this.state == OutputStateChange.Undefined)\n                                    this.start()\n                                else if (this.state == OutputStateChange.Pause) this.resume()\n                                break\n                            case OutputStateChange.Stop:\n                                this.stop()\n                                break\n                            case OutputStateChange.Pause:\n                                this.pause()\n                                break\n                            case OutputStateChange.Undefined:\n                                break\n                            case OutputStateChange.Swap:\n                                Error(\n                                    'this should not happen -- OutputEngine should handle swaps and never send them on',\n                                )\n                                break\n                        }\n                        this.state = val\n                    }\n                }),\n                debug(SonificationLoggingLevel.DEBUG, `output`, DEBUG),\n            )\n            .subscribe(this)\n    }\n\n    /**\n     * Stop all output. Stream has ended.\n     */\n    complete(): void {\n        this.stop()\n        this.subscription?.unsubscribe()\n    }\n\n    /**\n     * Stop all output.\n     */\n    protected stop() {}\n    /**\n     * Do any setup for outputing node\n     */\n    protected start() {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'Play was called')\n    }\n\n    /**\n     * Pause any output\n     */\n    protected pause() {}\n\n    /**\n     * Resume any output\n     */\n    protected resume() {}\n\n    /**\n     * Show the output\n     */\n    protected output(datum: Datum) {\n        debugStatic(SonificationLoggingLevel.DEBUG, `updating value  ${datum}`)\n    }\n\n    /**\n     * Prints a description of this output\n     */\n    public toString(): string {\n        return `${lastValueFrom(this)}$`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } else console.log('debug message dumped')\n    }\n}\n","import assert from 'assert'\nimport { Datum } from '../Datum'\nimport { Sonify } from './Sonify'\n/**\n * Abstract class for sonifying a data point as a pitch.\n * @extends Sonify\n * @todo only plays noise once. investigate further. probably have to create new noise nodes for each point.\n *\n */\nexport abstract class SonifyFixedDuration extends Sonify {\n    /** duration in seconds */\n    protected duration = 0.1\n\n    /** StartTime is undefined if the node isn't playing */\n    private startTime: number | undefined = undefined\n\n    /**\n     * Creates a Fixed Duration sound output.\n     * @param volume The level to play at\n     * @param audioNode An audio node to connect up to make sounds\n     * @param duration How long the node should play for\n     */\n    constructor(audioNode?: AudioScheduledSourceNode, duration?: number,pan:number=0) {\n        super(audioNode,pan)\n        if (duration) this.duration = duration\n    }\n\n    /**\n     * Set the audio node.\n     */\n    protected set audioNode(value: AudioNode | undefined) {\n        if (value as AudioScheduledSourceNode) this.audioNode = value\n        else throw new Error('Fixed duration nodes must be AudioScheduledSourceNode')\n    }\n\n    /**\n     * Call extend if the audio node is still playing\n     * Otherwise just show this data point\n     */\n    output(datum: Datum): void {\n        if (this.startTime) {\n            let timePlayed = SonifyFixedDuration.audioCtx.currentTime - this.startTime\n            let timeLeft = this.duration - timePlayed\n            this.extend(timeLeft + this.duration)\n        } else {\n            let node = this.create(datum)\n            node.onended = () => this.resetAudioNode()\n        }\n    }\n\n    /**\n     * Create a new output for this datum\n     */\n    protected abstract create(datum: Datum): AudioScheduledSourceNode\n\n    /**\n     * Extend the time the audio node is playing for\n     * Must be defined for this to work, is node specific\n     */\n    protected abstract extend(timeAdd: number)\n\n    /**\n     * Reset audio node to undefined.\n     * useful for sonifications that need a new node every time. e.g. noise and potentially speech.\n     */\n    public resetAudioNode() {\n        this.outputNode = undefined\n        this.startTime = undefined\n    }\n}\n","import { Observable, tap } from 'rxjs'\nimport { Datum } from './Datum'\n\n/**\n * SonificationLevel is typically associated with a specific point being sonified\n * It is intended to be used similar to aria-live tags=\"polite\",\"assertive\", etc. for sonification\n *\n * @todo figure out where in the architecture this can/should be used. Is it per data sink for example?\n * @readonly\n * @enum {number}\n */\nexport enum SonificationLevel {\n    polite, //does not interrupt previously sonifying data.\n    assertive, // cancels all current sonifications and plays the current point\n}\n\n/**\n * The current state of the audio context.\n * @readonly\n * @enum {number}\n */\nexport enum OutputStateChange {\n    /** Output should start (become visible/audible) */\n    Play,\n    /** Output should pause */\n    Pause,\n    /** Output should end */\n    Stop,\n    /** Output state unknown */\n    Undefined,\n    /** Swap States (between Pause and Play)*/\n    Swap,\n}\n\n/**\n * Used by statistics keeping track of a value with regard to the data domain\n */\nexport enum GrowthDirection {\n    Max,\n    Min,\n}\n\n/**\n * For debugging\n */\nexport enum SonificationLoggingLevel {\n    TRACE,\n    DEBUG,\n    INFO,\n    ERROR,\n}\n\nlet sonificationLoggingLevel = SonificationLoggingLevel.DEBUG\n\nexport function getSonificationLoggingLevel(): SonificationLoggingLevel {\n    return sonificationLoggingLevel\n}\nexport function setSonificationsLoggingLevel(level: SonificationLoggingLevel) {\n    sonificationLoggingLevel = level\n}\n","import { filter, Observable, tap } from 'rxjs'\nimport { DatumOutput } from '../output/DatumOutput'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from '../OutputConstants'\nimport { DataHandler } from './DataHandler'\n\nconst DEBUG = true\n\n/**\n * A DataHandler that tracks the extrema of the data.\n */\nexport class RunningExtremaHandler extends DataHandler {\n\n    /**\n     * The relative extrema given the data thus far.\n     */\n    private _extrema: number\n    public get extrema(): number {\n        return this._extrema\n    }\n    public set extrema(value: number) {\n        this._extrema = value\n    }\n\n    /**\n     * Which extrema we're parsing for: -1 for minimum, 1 for maximum\n     */\n    private _direction: number\n    public get direction(): number {\n        return this._direction\n    }\n    public set direction(value: number) {\n        this._direction = value\n    }\n\n    /**\n     * Constructor\n     *\n     * @param sink. DataSink that is providing data to this Handler.\n     * @param output. Optional output for this data\n     * @param direction. -1 for minimum, 1 for maximum. Default to maximum if not provided.\n     */\n    constructor(direction?: number, output?: DatumOutput) {\n        super(output)\n        if (direction) {\n            this._direction = direction\n        } else {\n            this._direction = 1\n        }\n        if (this._direction == 1) {\n            this._extrema = Number.MIN_VALUE\n        } else {\n            this._extrema = Number.MAX_VALUE\n        }\n    }\n\n    /**\n     * Set up a subscription so we are notified about events\n     * Override this if the data needs to be modified in some way\n     *\n     * @param sink The sink that is producing data for us\n     */\n    public setupSubscription(sink$: Observable<OutputStateChange | Datum>) {\n        debugStatic (SonificationLoggingLevel.DEBUG, `setting up subscription for ${this} ${sink$}`)\n        super.setupSubscription(\n            sink$.pipe(\n                filter((val) => {\n                    if (val instanceof Datum){\n                        debugStatic(SonificationLoggingLevel.DEBUG, `checking if ${val} is new extrema`)\n                        if (this._direction == 1) {\n                            if (val.value > this._extrema) {\n                                if (DEBUG) console.log(\"new maximum\", val.value)\n                                this._extrema = val.value\n                                return true\n                            }\n                            return false\n                        } else {\n                            if (val.value < this._extrema) {\n                                if (DEBUG) console.log(\"new minimum\", val.value)\n                                this._extrema = val.value\n                                return true\n                            }\n                            return false\n                        }\n                    }\n                    else return true\n                }),\n            ),\n        )\n    }\n\n    /**\n     * @returns A string describing this class including its range.\n     */\n    public toString(): string {\n        return `RunningExtremaHandler`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nimport { Datum } from '../Datum'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } else console.log('debug message dumped')\n    }\n}\n","import { tap, Observable } from 'rxjs'\nimport { Datum } from '../Datum'\nimport { getSonificationLoggingLevel, SonificationLoggingLevel } from '../OutputConstants'\nimport { Sonify } from './Sonify'\nimport { SonifyFixedDuration } from './SonifyFixedDuration'\nconst DEBUG = false\n\n/**\n * Class for sonifying a data point as a pitch.\n * @extends Sonify\n * @todo only plays noise once. investigate further. probably have to create new noise nodes for each point.\n */\nexport class NoiseSonify extends SonifyFixedDuration {\n    /**\n     * This is the node that knows how to play noise. It is connected to the this.audioNode\n     */\n    private filter: BiquadFilterNode | undefined\n\n    protected extend(timeAdd: number) {\n        let noiseNode = this.outputNode as AudioBufferSourceNode\n        debugStatic(SonificationLoggingLevel.DEBUG, `noiseSonify, getting noise node ${noiseNode}`)\n        if (noiseNode) noiseNode.buffer = this.fillBuffer(timeAdd)\n    }\n\n    /**\n     * create a buffer and fill it\n     * @param time Time to fill it for in seconds\n     */\n    private fillBuffer(length: number): AudioBuffer {\n        let sampleRate = Sonify.audioCtx.sampleRate\n        let noiseBufferSize = sampleRate * length\n        let buffer = NoiseSonify.audioCtx.createBuffer(1, noiseBufferSize, NoiseSonify.audioCtx.sampleRate)\n        let bufferData = buffer.getChannelData(0)\n        debugStatic(SonificationLoggingLevel.DEBUG, 'filling in buffer data')\n        for (let i = 0; i < noiseBufferSize; i++) {\n            bufferData[i] = Math.random() * 2 - 1\n        }\n        return buffer\n    }\n\n    public create(datum: Datum): AudioScheduledSourceNode {\n        let outputNode = NoiseSonify.audioCtx.createBufferSource()\n        this.filter = NoiseSonify.audioCtx.createBiquadFilter()\n        this.filter.type = 'bandpass'\n        this.filter.frequency.value = 440\n        this.filter.connect(this.gainNode)\n\n        outputNode.buffer = this.fillBuffer(this.duration)\n        outputNode.connect(this.filter)\n        this.outputNode = outputNode\n        outputNode.start()\n        return outputNode\n    }\n\n    public toString(): string {\n        return `NoiseSonify`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } //else console.log('debug message dumped')\n    }\n}\n","import * as aq from 'arquero'\n\nexport type DataListener = (table: any) => void\nexport class DataManager {\n    private static instance: DataManager\n\n    private constructor() {}\n\n    public static getInstance(): DataManager {\n        if (!DataManager.instance) {\n            DataManager.instance = new DataManager()\n        }\n        return DataManager.instance\n    }\n\n    private _listeners: DataListener[] = []\n    public table: any\n\n    public loadDataFromUrl(url: string) {\n        // Check for empty strings\n        // TODO check for valid url formats, or try to clean up incomplete urls - e.g. add https://\n        if (!url || url.trim() === '') {\n            console.log('Invalid url provided for data. Could not load.')\n            return\n        }\n\n        // TODO Handle error responses\n        fetch(url).then((res) => res.text().then((text) => DataManager.instance.loadDataFromText(text)))\n    }\n\n    public loadDataFromText(text: string) {\n        // Check for empty strings, bad data, anything else?\n        if (!text || text.trim() === '') {\n            console.log('Invalid text provided for data. Could not load.')\n            return\n        }\n\n        // Determine if the input text is tab or comma separated values\n        // Compute the number of tabs and lines\n        let tabNum = 0,\n            lineNum = 0\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\t') tabNum++\n            if (text.charAt(i) === '\\n') lineNum++\n        }\n\n        // If one or more tab per line, then it is tab separated values\n        let isTabSeparated = tabNum / lineNum >= 1\n        let delimiter = isTabSeparated ? '\\t' : ','\n\n        // TODO: Determine if the input has headers, for now check if only one line of data\n        let header = lineNum > 0\n        console.log(header, tabNum, lineNum)\n\n        this.table = aq.fromCSV(text, { delimiter, header })\n        console.log(this.table.columns())\n        console.log(this.table)\n        this.handleDataChange()\n    }\n\n    public loadDataFromFile(file: File) {\n        file.text().then((text) => DataManager.instance.loadDataFromText(text))\n    }\n\n    public handleDataChange() {\n        for (let i = 0; i < this._listeners.length; i++) {\n            this._listeners[i](this.table)\n        }\n    }\n\n    public addListener(listener: DataListener) {\n        this._listeners.push(listener)\n    }\n\n    public removeListener(listener: DataListener) {\n        for (let i = 0; i < this._listeners.length; i++) {\n            if (listener === this._listeners[i]) {\n                this._listeners.splice(i, 1)\n            }\n        }\n    }\n}\n","import React, { ChangeEvent } from 'react'\n\nimport {\n    Button,\n    Box,\n    Grid,\n    Input,\n    Stack,\n    TextareaAutosize,\n    ToggleButtonGroup,\n    ToggleButton,\n    Typography,\n    TextField,\n    FormControl,\n    InputLabel,\n    FormHelperText,\n    NativeSelect,\n} from '@mui/material'\nimport { ContentPaste, UploadFile, Link, ListAlt } from '@mui/icons-material'\n\nimport { DataManager } from '../DataManager'\n\nconst EXAMPLE_LIST = [\n    { fileName: 'sawtooth_wave.csv', displayName: 'Sawtooth Wave' },\n    { fileName: 'sine_wave.csv', displayName: 'Sine Wave' },\n    { fileName: 'square_wave.csv', displayName: 'Square Wave' },\n]\n\nexport interface ImportViewState {\n    importType: string\n    exampleValue: string\n}\n\nexport interface ImportViewProps {}\n\nexport class ImportView extends React.Component<ImportViewProps, ImportViewState> {\n    private _selectExample: React.RefObject<HTMLDivElement>\n    private _textArea: React.RefObject<HTMLTextAreaElement>\n    private _inputFile: React.RefObject<HTMLInputElement>\n    private _textField: React.RefObject<HTMLDivElement>\n\n    constructor(props: ImportViewProps) {\n        super(props)\n        this.state = {\n            importType: 'example',\n            exampleValue: EXAMPLE_LIST[0].fileName,\n        }\n\n        this._selectExample = React.createRef()\n        this._textArea = React.createRef()\n        this._inputFile = React.createRef()\n        this._textField = React.createRef()\n        this._handleExampleChange()\n    }\n\n    public render() {\n        let { importType, exampleValue } = this.state\n\n        let inputElement, headerText, bodyText\n\n        let continueButton: any = (\n            <Button variant=\"contained\" sx={{ mt: 1, mr: 1 }} onClick={this._handleClickContinue}>\n                Continue\n            </Button>\n        )\n\n        switch (importType) {\n            case 'example':\n                inputElement = (\n                    <FormControl>\n                        <InputLabel variant=\"standard\" htmlFor=\"example-data-select\" id=\"example-data-label\">\n                            Example Data\n                        </InputLabel>\n                        <NativeSelect\n                            ref={this._selectExample}\n                            aria-label=\"Choose example data\"\n                            id=\"example-data-select\"\n                            placeholder=\"Enter data here\"\n                            value={exampleValue}\n                            variant=\"standard\"\n                            onChange={this._handleExampleChange}\n                        >\n                            {EXAMPLE_LIST.map((e) => (\n                                <option value={e.fileName} key={e.fileName}>\n                                    {e.displayName}\n                                </option>\n                            ))}\n                        </NativeSelect>\n                    </FormControl>\n                )\n                headerText = 'Choose from example data'\n                bodyText = 'Choose an example data file from the provided list.'\n                continueButton = undefined\n                break\n            case 'paste':\n                inputElement = (\n                    <TextareaAutosize\n                        ref={this._textArea}\n                        aria-label=\"Textarea for data entry\"\n                        placeholder=\"Enter data here\"\n                        style={{ width: '100%', maxHeight: '400px', overflow: 'scroll' }}\n                        minRows={5}\n                    />\n                )\n                headerText = 'Copy & paste your data'\n                bodyText =\n                    'Select your table from a spreadsheet and paste it in the text field. We support comma/tab separated values (i.e., CSV, TSV).'\n                break\n            case 'file':\n                inputElement = (\n                    <label htmlFor=\"input-upload-file\" aria-label=\"Choose file\">\n                        <Box component=\"div\" sx={{ p: 2, border: '2px dashed #aaa' }}>\n                            <Button component=\"label\">\n                                Upload\n                                <Input\n                                    style={{ display: 'none' }}\n                                    aria-hidden={true}\n                                    ref={this._inputFile}\n                                    type=\"file\"\n                                    id=\"input-upload-file\"\n                                    onChange={this._handleFileChange}\n                                />\n                            </Button>\n                        </Box>\n                    </label>\n                )\n                headerText = 'Upload your data file'\n                bodyText = 'Choose your local data file (*.csv or *.tsv) to upload.'\n                continueButton = undefined\n                break\n            case 'link':\n                inputElement = (\n                    <TextField\n                        ref={this._textField}\n                        id=\"my-input\"\n                        aria-label=\"Text field for data url\"\n                        label=\"Data URL\"\n                    />\n                )\n                headerText = 'Link to your external data'\n                bodyText =\n                    'Enter a valid url to an external data file. We support comma/tab separated values (i.e., CSV, TSV).'\n                break\n        }\n\n        return (\n            <div>\n                <h2>How do you want to upload your data?</h2>\n                <div>\n                    <Grid container spacing={2}>\n                        <Grid item xs={4} sm={3} md={2}>\n                            <ToggleButtonGroup\n                                orientation=\"vertical\"\n                                value={importType}\n                                onChange={this._handleImportTypeChange}\n                                exclusive\n                            >\n                                <ToggleButton value=\"example\">\n                                    <ListAlt />\n                                    <span\n                                        style={{\n                                            textTransform: 'none',\n                                            marginLeft: '0.5rem',\n                                            textAlign: 'left',\n                                            maxWidth: '100px',\n                                            lineHeight: '1.4',\n                                        }}\n                                    >\n                                        Choose from example data\n                                    </span>\n                                </ToggleButton>\n                                <ToggleButton value=\"paste\">\n                                    <ContentPaste />\n                                    <span\n                                        style={{\n                                            textTransform: 'none',\n                                            marginLeft: '0.5rem',\n                                            textAlign: 'left',\n                                            maxWidth: '100px',\n                                            lineHeight: '1.4',\n                                        }}\n                                    >\n                                        Copy & paste data table\n                                    </span>\n                                </ToggleButton>\n                                <ToggleButton value=\"file\">\n                                    <UploadFile />\n                                    <span\n                                        style={{\n                                            textTransform: 'none',\n                                            marginLeft: '0.5rem',\n                                            textAlign: 'left',\n                                            maxWidth: '100px',\n                                            lineHeight: '1.4',\n                                        }}\n                                    >\n                                        Upload CSV or TSV file\n                                    </span>\n                                </ToggleButton>\n                                <ToggleButton value=\"link\">\n                                    <Link />\n                                    <span\n                                        style={{\n                                            textTransform: 'none',\n                                            marginLeft: '0.5rem',\n                                            textAlign: 'left',\n                                            maxWidth: '100px',\n                                            lineHeight: '1.4',\n                                        }}\n                                    >\n                                        Link to external url\n                                    </span>\n                                </ToggleButton>\n                            </ToggleButtonGroup>\n                        </Grid>\n                        <Grid item xs={8} sm={9} md={8}>\n                            <div>\n                                <Stack spacing={1}>\n                                    <Typography variant=\"h6\" color=\"text.secondary\">\n                                        {headerText}\n                                    </Typography>\n                                    {inputElement}\n                                    <Typography variant=\"body2\">{bodyText}</Typography>\n                                    {continueButton}\n                                </Stack>\n                            </div>\n                        </Grid>\n                        <Grid item xs={0} sm={0} md={2}></Grid>\n                    </Grid>\n                </div>\n            </div>\n        )\n    }\n\n    private _handleClickContinue = (event: React.MouseEvent<HTMLElement>) => {\n        switch (this.state.importType) {\n            case 'example':\n            case 'file':\n                break\n            case 'paste':\n                if (this._textArea && this._textArea.current) {\n                    let text = this._textArea.current.value.trim()\n                    DataManager.getInstance().loadDataFromText(text)\n                }\n                break\n            case 'link':\n                if (this._textField && this._textField.current) {\n                    let input = this._textField.current.querySelector('input')\n                    if (input && input.value) {\n                        let url = input.value.trim()\n                        DataManager.getInstance().loadDataFromUrl(url)\n                    }\n                }\n                break\n        }\n    }\n\n    // https://raw.githubusercontent.com/vega/vega-datasets/next/data/stocks.csv\n\n    private _handleFileChange = (event: React.FormEvent<HTMLElement>) => {\n        let target: any = event.target\n        if (target && target.files && target.files.length === 1) {\n            console.log(event)\n            let file: File = target.files[0]\n            DataManager.getInstance().loadDataFromFile(file)\n        }\n    }\n\n    private _handleExampleChange = (event?: ChangeEvent<HTMLSelectElement>) => {\n        let exampleValue = event?.target.value ? event.target.value : this.state.exampleValue\n        this.setState({ exampleValue })\n        let url = `./data/${exampleValue}`\n        DataManager.getInstance().loadDataFromUrl(url)\n    }\n\n    private _handleImportTypeChange = (event: React.MouseEvent<HTMLElement>, importType: string) => {\n        // Only change import type if another one has been selected, otherwise keep the same\n        if (importType) {\n            this.setState({ importType })\n        }\n    }\n}\n","import React from 'react'\n\nimport { DataGrid } from '@mui/x-data-grid'\nimport { DataManager } from '../DataManager'\n\nexport interface DataViewState {\n    columns: any[]\n    rows: any[]\n}\n\nexport interface DataViewProps {}\n\nexport class DataView extends React.Component<DataViewProps, DataViewState> {\n    constructor(props: DataViewProps) {\n        super(props)\n        this.state = {\n            rows: [],\n            columns: [],\n        }\n\n        DataManager.getInstance().addListener(this.handleDataUpdate)\n    }\n\n    public render() {\n        const { rows, columns } = this.state\n        const loaded = rows.length > 0 && columns.length > 0\n        console.log(columns)\n\n        return (\n            <div style={{ height: 500, width: '100%' }} aria-live=\"polite\">\n                {loaded && <DataGrid rows={rows} columns={columns} />}\n            </div>\n        )\n    }\n\n    public handleDataUpdate = (table: any): void => {\n        const columns = table\n            .columnNames()\n            .map((c) => ({ field: c, headerName: c, width: 160, renderHeader: (params: any) => <strong>{c}</strong> }))\n        const rows = table.objects().map((o, i) => Object.assign({ id: i }, o))\n\n        this.setState({ columns, rows })\n    }\n}\n","import React from 'react'\nimport { Observable, of, tap, timer, zip, delay } from 'rxjs'\nimport { DataSink } from '../../sonification/DataSink'\nimport { Datum } from '../../sonification/Datum'\nimport { OutputEngine } from '../../sonification/OutputEngine'\nimport { NoteHandler } from '../../sonification/handler/NoteHandler'\nimport { IDemoView } from './IDemoView'\nimport {\n    getSonificationLoggingLevel,\n    OutputStateChange,\n    SonificationLoggingLevel,\n} from '../../sonification/OutputConstants'\nimport { Demo } from '../../pages/Demo'\nimport { NoteSonify } from '../../sonification/output/NoteSonify'\n\nconst DEBUG = false\n\nexport interface DemoSimpleState {}\n\nexport interface DemoSimpleProps {\n    dataSummary: any\n}\n\nexport class DemoSimple<DemoSimpleProps, DemoSimpleState>\n    extends React.Component<DemoSimpleProps, DemoSimpleState>\n    implements IDemoView\n{\n    /**\n     * @todo implement pausing\n     * The index into our data set that we were at when we were paused\n     */\n    protected current = 0\n\n    /**\n     * Holder for data set to sonify\n     */\n    protected data: number[] | undefined\n\n    /**\n     * Holder for the current DataSink object\n     */\n    protected sink: DataSink | undefined\n    public getSink(): DataSink {\n        if (this.sink) return this.sink\n        else return this.initializeSink()\n    }\n\n    /**\n     * Holder for the current DataSink object that starts after a delay\n     */\n    protected delaySink: DataSink | undefined\n    public getDelaySink() {\n        if (this.delaySink) return this.delaySink\n        else return this.initializeDelaySink()\n    }\n    initializeDelaySink() {\n        // SONIFICATION\n        debugStatic(SonificationLoggingLevel.DEBUG, `adding sink`)\n\n        this.delaySink = OutputEngine.getInstance().addSink('SimpleDemoDelaySink')\n\n        // debugStatic(SonificationLoggingLevel.DEBUG, `adding Handler`)\n\n        // this.sink?.addDataHandler(new NoteHandler(undefined, new NoteSonify()))\n\n        debugStatic(SonificationLoggingLevel.DEBUG, `success initializing sink ${this.sink}`)\n\n        return this.delaySink\n    }\n\n    /**\n     * @todo fix comments and debug\n     * @param data Not sure what this is -- someone else wrote ti\n     */\n    public onPause = (data: any) => {\n        OutputEngine.getInstance().next(OutputStateChange.Pause)\n    }\n\n    /**\n     * The play button has been pressed and data set specified. Time to start sonificatino\n     *\n     * First, since we now know what data we are playing, this adds a max/min calculator\n     * to our DataSink. The calculation is based on the full data set and always returns the\n     * same value as a result\n     * @todo think about how to set up static calculations so they don't run over and over again.\n     *\n     * Second, we make a callback to the OutputEngine instance to let it know to shift into play mode\n     * Third, we create a data stream\n     *\n     * @param data The data set to be played\n     */\n    public onPlay = (data: Array<number>) => {\n        debugStatic(SonificationLoggingLevel.DEBUG, `in onPlay ${this.sink}, ${this.delaySink} `)\n        debugStatic(SonificationLoggingLevel.DEBUG, `adding sink`)\n\n        if (this.sink == undefined) this.sink = this.initializeSink()\n\n        //if(this.delaySink == undefined) this.delaySink = this.initializeDelaySink()\n\n        let id = this.sink ? this.sink.id : 0\n\n        //let delayID = this.delaySink ? this.delaySink.id : 1\n\n        let dataCopy = Object.assign([], data)\n        let data$ = of(...data) //.slice(0, 8))\n        let delayData$ = of(...dataCopy) //.slice(0, 8))\n\n        let timer$ = timer(0, 250).pipe(debug(SonificationLoggingLevel.DEBUG, 'point number'))\n\n        let source$ = zip(data$, timer$, (num, time) => new Datum(id, num)).pipe(\n            debug(SonificationLoggingLevel.DEBUG, 'point'),\n        )\n\n        /// Make sure to delete the sink when the source is\n        source$.subscribe({\n            complete: () => {\n                this.sink = undefined\n                //Demo.setState({ playbackLabel: \"Play\" })\n            },\n        })\n\n        debugStatic(SonificationLoggingLevel.DEBUG, 'calling setStream')\n        OutputEngine.getInstance().setStream(id, source$)\n\n        debugStatic(SonificationLoggingLevel.DEBUG, `adding Handler`)\n        this.sink?.addDataHandler(\n            new NoteHandler(\n                [\n                    data.reduce((prev, curr) => (prev < curr ? prev : curr)), // min\n                    data.reduce((prev, curr) => (prev > curr ? prev : curr)),\n                ],\n                new NoteSonify(-1),\n            ),\n        ) // max\n        debugStatic(SonificationLoggingLevel.DEBUG, `success`)\n\n        /*let delayTimer$ = timer(0, 250).pipe(debug(SonificationLoggingLevel.DEBUG, 'point number'))\n\n        let delaySource$ = zip(delayData$, delayTimer$, (num, time) => new Datum(delayID, num)).pipe(delay(1000)).pipe(\n            debug(SonificationLoggingLevel.DEBUG, 'delayPoint'),\n        )\n        OutputEngine.getInstance().setStream(delayID, delaySource$)\n\n        */\n        /// Make sure to delete the sink when the source is\n        /*delaySource$.subscribe({\n\n\n        /// Make sure to delete the sink when the source is\n            complete: () => {\n                this.delaySink = undefined\n                //Demo.setState({ playbackLabel: \"Play\" })\n            },\n        })\n\n\n        debugStatic(SonificationLoggingLevel.DEBUG, `adding Handler to ${this.delaySink}`)\n        this.delaySink?.addDataHandler(\n            new NoteHandler([\n                data.reduce((prev, curr) => (prev < curr ? prev : curr)), // min\n                data.reduce((prev, curr) => (prev > curr ? prev : curr)),\n            ], new NoteSonify(1)),\n\n        )*/ // max\n\n        console.log('sending play')\n        // Change State\n        OutputEngine.getInstance().next(OutputStateChange.Play)\n    }\n\n    public render() {\n        return (\n            <div>\n                <p> press play to hear a simple sonification</p>\n            </div>\n        )\n    }\n\n    /**\n     * Garbage collect our data stream.\n     */\n    public componentWillUnmount() {\n        OutputEngine.getInstance().next(OutputStateChange.Stop)\n        if (this.sink) {\n            OutputEngine.getInstance().deleteSink(this.sink)\n        }\n    }\n\n    ////////// HELPER METHODS ///////////////\n    /**\n     * This initializes the sink, but to work fully, it is important to also\n     * assign max and min values when the data set is specified.\n     * @returns a sink\n     */\n    public initializeSink() {\n        // SONIFICATION\n        debugStatic(SonificationLoggingLevel.DEBUG, `adding sink`)\n\n        this.sink = OutputEngine.getInstance().addSink('SimpleDemoSink')\n\n        // debugStatic(SonificationLoggingLevel.DEBUG, `adding Handler`)\n\n        // this.sink?.addDataHandler(new NoteHandler(undefined, new NoteSonify()))\n\n        debugStatic(SonificationLoggingLevel.DEBUG, `success initializing sink ${this.sink}`)\n\n        return this.sink\n    }\n}\n\nconst debug = (level: number, message: string) => (source: Observable<any>) =>\n    source.pipe(\n        tap((val) => {\n            debugStatic(level, message + ': ' + val)\n        }),\n    )\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } //else console.log('debug message dumped')\n    }\n}\n","import React from 'react'\n\nimport { TextField } from '@mui/material'\nimport { IDemoView } from './IDemoView'\nimport { FilterRangeHandler } from '../../sonification/handler/FilterRangeHandler'\nimport { NoiseSonify } from '../../sonification/output/NoiseSonify'\nimport { DemoSimple, DemoSimpleProps, DemoSimpleState } from './DemoSimple'\nimport { NoteHandler } from '../../sonification/handler/NoteHandler'\nimport { OutputEngine } from '../../sonification/OutputEngine'\nimport { FileOutput } from '../../sonification/output/FileOutput'\nimport { NoteSonify } from '../../sonification/output/NoteSonify'\n\nexport interface DemoHighlightRegionState extends DemoSimpleState {\n    minValue: number\n    maxValue: number\n}\nexport interface DemoHighlightRegionProps extends DemoSimpleProps {\n    dataSummary: any\n}\n\n// I don't know react well enough -- can this extend demosimple instead? Would be much simpler...\n// would still need to get the highlightRegionProps...\n// there is a lot of duplication between this and DemoSimple right now...\nexport class DemoHighlightRegion\n    extends DemoSimple<DemoHighlightRegionProps, DemoHighlightRegionState>\n    implements IDemoView\n{\n    filter: FilterRangeHandler | undefined\n\n    constructor(props: DemoHighlightRegionProps) {\n        super(props)\n        this.state = {\n            minValue: this.props.dataSummary.min,\n            maxValue: this.props.dataSummary.max,\n        }\n    }\n\n    public render() {\n        const { minValue, maxValue } = this.state\n\n        return (\n            <div>\n                <TextField\n                    id=\"text-min-value\"\n                    aria-label=\"Enter minimum value\"\n                    label=\"Min\"\n                    variant=\"outlined\"\n                    type=\"number\"\n                    value={isNaN(minValue) ? '' : minValue}\n                    onChange={(e) => this._handleValueChange(parseFloat(e.target.value), 'min')}\n                />\n                <TextField\n                    id=\"text-max-value\"\n                    aria-label=\"Enter maximum value\"\n                    label=\"Max\"\n                    variant=\"outlined\"\n                    type=\"number\"\n                    value={isNaN(maxValue) ? '' : maxValue}\n                    onChange={(e) => this._handleValueChange(parseFloat(e.target.value), 'max')}\n                />\n            </div>\n        )\n    }\n\n    /**\n     * Something was updated in this class.\n     * Make sure that we are updating our filter to reflect the new min/max values\n     * @param prevProps new min/max value\n     */\n    public componentDidUpdate(prevProps: DemoHighlightRegionProps) {\n        // When the data summary changes, update the min & max value\n        if (\n            this.props.dataSummary.min !== prevProps.dataSummary.min ||\n            this.props.dataSummary.max !== prevProps.dataSummary.max\n        ) {\n            let minValue = this.props.dataSummary.min,\n                maxValue = this.props.dataSummary.max\n            this.setState({ minValue, maxValue })\n        }\n        // SONIFICATION\n        if (this.filter) this.filter.domain = [this.state.minValue, this.state.maxValue]\n    }\n\n    private _handleValueChange = (value: number, which: string) => {\n        switch (which) {\n            case 'min':\n                this.setState({ minValue: value })\n                break\n            case 'max':\n                this.setState({ maxValue: value })\n                break\n        }\n    }\n\n    ////////// HELPER METHODS ///////////////\n    public initializeSink() {\n        this.sink = OutputEngine.getInstance().addSink('HighlightRegionDemo')\n        /**\n         * @todo vpotluri to understand: where is the update datum method for this being called?\n         */\n        this.filter = new FilterRangeHandler([this.state.minValue, this.state.maxValue], new NoiseSonify(undefined,undefined,-1))\n        \n        \n        this.sink.addDataHandler(this.filter)\n        this.sink.addDataHandler(new NoteHandler(undefined, new NoteSonify()))\n        \n        return this.sink\n    }\n}\n","import React from 'react'\n\nimport { TextField } from '@mui/material'\nimport { IDemoView } from './IDemoView'\nimport { FilterRangeHandler } from '../../sonification/handler/FilterRangeHandler'\nimport { Speech } from '../../sonification/output/Speech'\nimport { DemoSimple, DemoSimpleProps, DemoSimpleState } from './DemoSimple'\nimport { NoteHandler } from '../../sonification/handler/NoteHandler'\nimport { OutputEngine } from '../../sonification/OutputEngine'\n// import { SpeechHandler } from '../../sonification/handler/SpeechHandler'\n\nexport interface DemoSpeakRangeState extends DemoSimpleState {\n    minValue: number\n    maxValue: number\n}\nexport interface DemoSpeakRangeProps extends DemoSimpleProps {\n    dataSummary: any\n}\n\nexport class DemoSpeakRange extends DemoSimple<DemoSpeakRangeProps, DemoSpeakRangeState> implements IDemoView {\n    filter: FilterRangeHandler | undefined\n\n    constructor(props: DemoSpeakRangeProps) {\n        super(props)\n        this.state = {\n            minValue: this.props.dataSummary.min,\n            maxValue: this.props.dataSummary.max,\n        }\n    }\n\n    public render() {\n        const { minValue, maxValue } = this.state\n\n        return (\n            <div>\n                <TextField\n                    id=\"text-min-value\"\n                    aria-label=\"Enter minimum value\"\n                    label=\"Min\"\n                    variant=\"outlined\"\n                    type=\"number\"\n                    value={isNaN(minValue) ? '' : minValue}\n                    onChange={(e) => this._handleValueChange(parseFloat(e.target.value), 'min')}\n                />\n                <TextField\n                    id=\"text-max-value\"\n                    aria-label=\"Enter maximum value\"\n                    label=\"Max\"\n                    variant=\"outlined\"\n                    type=\"number\"\n                    value={isNaN(maxValue) ? '' : maxValue}\n                    onChange={(e) => this._handleValueChange(parseFloat(e.target.value), 'max')}\n                />\n            </div>\n        )\n    }\n\n    /**\n     * @param prevProps new min/max value\n     */\n    public componentDidUpdate(prevProps: DemoSpeakRangeProps) {\n        // When the data summary changes, update the min & max value\n        if (\n            this.props.dataSummary.min !== prevProps.dataSummary.min ||\n            this.props.dataSummary.max !== prevProps.dataSummary.max\n        ) {\n            let minValue = this.props.dataSummary.min,\n                maxValue = this.props.dataSummary.max\n            this.setState({ minValue, maxValue })\n        }\n        if (this.filter) this.filter.domain = [this.state.minValue, this.state.maxValue]\n    }\n\n    private _handleValueChange = (value: number, which: string) => {\n        switch (which) {\n            case 'min':\n                this.setState({ minValue: value })\n                break\n            case 'max':\n                this.setState({ maxValue: value })\n                break\n        }\n    }\n\n    ////////// HELPER METHODS ///////////////\n    public initializeSink() {\n        this.sink = OutputEngine.getInstance().addSink('SpeakRangeDemo')\n        this.filter = new FilterRangeHandler([this.state.minValue, this.state.maxValue], new Speech(undefined, undefined, undefined, undefined, true))\n        // this.sink.addDataHandler(new NoteHandler(undefined, new NoteSonify()))*/\n        // this.filter = new SpeechHandler(new Speech())\n        this.sink.addDataHandler(this.filter)\n        return this.sink\n    }\n}\n","import { DataSink } from '../DataSink'\nimport { Datum } from '../Datum'\nimport { DatumOutput } from '../output/DatumOutput'\nimport { DataHandler } from './DataHandler'\nimport { filter, Observable, tap } from 'rxjs'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLevel, SonificationLoggingLevel } from '../OutputConstants'\n\nconst DEBUG = true\n\n/**\n * A DataHandler that notifies if a set of point/s are seen\n  */\nexport class NotificationHandler extends DataHandler {\n    /**\n     * A set of points to be notified about. defaults to 0 if not specified in the constructor.\n     */\n    private _interestPoints: number[]\n    public get interestPoints(): number[] {\n        return this._interestPoints\n    }\n    public set interestPoints(value: number[]) {\n        this._interestPoints = value\n    }\n\n    /**\n     * checks if a given point is in the points of interest.\n     * @param num\n     * @returns true if a point is in the points of interest, else returns false.\n     */\n    public isInterestPoint(num: number) {\n        // return true\n\n        debugStatic(SonificationLoggingLevel.DEBUG,\"checking if \" + num + \" is in \" + this.interestPoints.toString())\n        return this.interestPoints.includes(num)\n\n    }\n\n    /**\n     * Constructor\n     *\n     * @param sink. DataSink that is providing data to this Handler.\n     * @param output. Optional output for this data\n     * @param interestPoints [number[]. Defaults to 0 if not provided\n     */\n    constructor(output?: DatumOutput, interestPoints?: number[]) {\n        super(output)\n        if (interestPoints) this._interestPoints = interestPoints\n        else this._interestPoints = [0]\n    }\n\n    /**\n     * Set up a subscription so we are notified about events\n     * Override this if the data needs to be modified in some way\n     *\n     * @param sink The sink that is producing data for us\n     */\n     public setupSubscription(sink$: Observable<OutputStateChange | Datum>) {\n        super.setupSubscription(\n            sink$.pipe(\n                filter((val) => {\n                    if (val instanceof Datum){\n                        return this.isInterestPoint(val.value)\n                    }\n                    else return true\n                }),\n            ),\n        )\n    }\n\n    /**\n     * @returns A string describing this class including its range.\n     */\n    public toString(): string {\n        return `NotificationHandler: notifying only if points are  in ${this.interestPoints}`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\n\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } else console.log('debug message dumped')\n    }\n}","import React from 'react'\n\nimport { TextField } from '@mui/material'\nimport { IDemoView } from './IDemoView'\nimport { NotificationHandler } from '../../sonification/handler/NotificationHandler'\nimport { FileOutput } from '../../sonification/output/FileOutput'\nimport { DemoSimple, DemoSimpleProps, DemoSimpleState } from './DemoSimple'\nimport { NoteHandler } from '../../sonification/handler/NoteHandler'\nimport { OutputEngine } from '../../sonification/OutputEngine'\nimport { Box, Button, Input } from '@mui/material'\n\nconst DEBUG = true\n\nexport interface DemoFileOutputState extends DemoSimpleState {\n    targetValues : number[]\n}\nexport interface DemoFileOutputProps extends DemoSimpleProps {\n    dataSummary: any\n}\n\nexport class DemoFileOutput\n    extends DemoSimple<DemoFileOutputProps, DemoFileOutputState>\n    implements IDemoView\n{\n    notifier: NotificationHandler | undefined\n    private _inputFile: React.RefObject<HTMLInputElement>\n    private _buffer: ArrayBuffer | undefined\n\n    constructor(props: DemoFileOutputProps) {\n        super(props)\n        this.state = {\n            // currently just chooses max as the default\n            targetValues: [this.props.dataSummary.max]\n        }\n        this._inputFile = React.createRef()\n    }\n\n    public render() {\n        const { targetValues } = this.state\n\n        return (\n            <div>\n                <label htmlFor=\"input-upload-file\" aria-label=\"Choose file\">\n                    <Box component=\"div\" sx={{ p: 2, border: '2px dashed #aaa', mb: 2 }}>\n                        <Button component=\"label\">\n                            Upload\n                            <Input\n                                style={{ display: 'none' }}\n                                aria-hidden={true}\n                                ref={this._inputFile}\n                                type=\"file\"\n                                id=\"input-upload-file\"\n                                onChange={this._handleFileChange}\n                            />\n                        </Button>\n                    </Box>\n                </label>\n                <TextField\n                    id=\"text-values\"\n                    aria-label=\"Enter the target value\"\n                    label=\"Points of interest\"\n                    variant=\"outlined\"\n                    onChange={(e) => this._handleValueChange(e.target.value)}\n                />\n            </div>\n        )\n    }\n\n    /**\n     * @param prevProps new min/max value\n     */\n    public componentDidUpdate(prevProps: DemoFileOutputProps) {\n        // When the data summary changes, update the min & max value\n        if (\n            this.props.dataSummary.min !== prevProps.dataSummary.min ||\n            this.props.dataSummary.max !== prevProps.dataSummary.max\n        ) {\n            let targetValues = [this.props.dataSummary.max]\n            this.setState({ targetValues })\n        }\n        if (this.notifier) this.notifier.interestPoints = this.state.targetValues\n    }\n\n    private _handleValueChange = (value: string) => {\n        let values = value.split(',')\n        let targets : number[] = []\n        for (let val of values) {\n            let numb = parseFloat(val)\n            if (!isNaN(numb)) {\n                targets.push(numb)\n            }\n        }\n        this.setState({ targetValues: targets})\n    }\n\n    private _handleFileChange = (event: React.FormEvent<HTMLElement>) => {\n      if (DEBUG) console.log(\"file changed!\")\n      let target: any = event.target\n      if (target && target.files && target.files.length === 1) {\n          console.log(event)\n          let file: File = target.files[0]\n          // process file\n          file.arrayBuffer().then((buffer) => {\n            // if (DEBUG) console.log(buffer.byteLength)\n            // byte length is not 0 from console.log statements\n            this._buffer = buffer\n            if (DEBUG) console.log(\"buffer updated!\")\n          }).catch(console.error)\n      }\n    }\n\n    ////////// HELPER METHODS ///////////////\n    public initializeSink() {\n        this.sink = OutputEngine.getInstance().addSink('FileOutputDemo')\n        this.notifier = new NotificationHandler(new FileOutput(this._buffer), this.state.targetValues)\n        if (DEBUG) console.log(\"sink initialized\")\n        //this.sink.addDataHandler(new NoteHandler())\n        this.sink.addDataHandler(this.notifier)\n        return this.sink\n    }\n}\n","import React from 'react'\n\nimport { TextField } from '@mui/material'\nimport { IDemoView } from './IDemoView'\nimport { SlopeParityHandler } from '../../sonification/handler/SlopeParityHandler'\nimport { FileOutput } from '../../sonification/output/FileOutput'\nimport { DemoSimple, DemoSimpleProps, DemoSimpleState } from './DemoSimple'\nimport { NoteHandler } from '../../sonification/handler/NoteHandler'\nimport { OutputEngine } from '../../sonification/OutputEngine'\nimport { Box, Button, Input } from '@mui/material'\nimport { NoteSonify } from '../../sonification/output/NoteSonify'\n\nconst DEBUG = true\n\nexport interface DemoSlopeParityV1State extends DemoSimpleState {\n    targetValues: number[]\n}\nexport interface DemoSlopeParityV1Props extends DemoSimpleProps {\n    dataSummary: any\n}\n\n// V1: indicate change in slope direction with single notification sound\nexport class DemoSlopeParityV1 extends DemoSimple<DemoSlopeParityV1Props, DemoSlopeParityV1State> implements IDemoView {\n    slopeHandler: SlopeParityHandler | undefined\n    private _inputFile: React.RefObject<HTMLInputElement>\n    private _buffer: ArrayBuffer | undefined\n\n    constructor(props: DemoSlopeParityV1Props) {\n        super(props)\n        this.state = {\n            // currently just chooses max as the default\n            targetValues: [this.props.dataSummary.max],\n        }\n        this._inputFile = React.createRef()\n    }\n\n    public render() {\n        const { targetValues } = this.state\n\n        return (\n            <div>\n                <label htmlFor=\"input-upload-file\" aria-label=\"Choose file\">\n                    <Box component=\"div\" sx={{ p: 2, border: '2px dashed #aaa', mb: 2 }}>\n                        <Button component=\"label\">\n                            Upload\n                            <Input\n                                style={{ display: 'none' }}\n                                aria-hidden={true}\n                                ref={this._inputFile}\n                                type=\"file\"\n                                id=\"input-upload-file\"\n                                onChange={this._handleFileChange}\n                            />\n                        </Button>\n                    </Box>\n                </label>\n            </div>\n        )\n    }\n\n    private _handleFileChange = (event: React.FormEvent<HTMLElement>) => {\n        if (DEBUG) console.log('file changed!')\n        let target: any = event.target\n        if (target && target.files && target.files.length === 1) {\n            console.log(event)\n            let file: File = target.files[0]\n            // process file\n            file.arrayBuffer()\n                .then((buffer) => {\n                    // if (DEBUG) console.log(buffer.byteLength)\n                    // byte length is not 0 from console.log statements\n                    this._buffer = buffer\n                    if (DEBUG) console.log('buffer updated!')\n                })\n                .catch(console.error)\n        }\n    }\n\n    ////////// HELPER METHODS ///////////////\n    public initializeSink() {\n        this.sink = OutputEngine.getInstance().addSink('DemoSlopeParityV1')\n        this.slopeHandler = new SlopeParityHandler(0, new FileOutput(this._buffer))\n        if (DEBUG) console.log('sink initialized')\n        this.sink.addDataHandler(new NoteHandler(undefined, new NoteSonify()))\n        this.sink.addDataHandler(this.slopeHandler)\n        return this.sink\n    }\n}\n","import React from 'react'\n\nimport { TextField } from '@mui/material'\nimport { IDemoView } from './IDemoView'\nimport { SlopeParityHandler } from '../../sonification/handler/SlopeParityHandler'\nimport { FileOutput } from '../../sonification/output/FileOutput'\nimport { DemoSimple, DemoSimpleProps, DemoSimpleState } from './DemoSimple'\nimport { NoteHandler } from '../../sonification/handler/NoteHandler'\nimport { OutputEngine } from '../../sonification/OutputEngine'\nimport { Box, Button, Input } from '@mui/material'\nimport { NoteSonify } from '../../sonification/output/NoteSonify'\n\nconst DEBUG = false\n\nexport interface DemoSlopeParityV2Props extends DemoSimpleProps {\n    dataSummary: any\n}\n\n// V2: indicate when the slope is increasing vs decreasing with separate notifications\nexport class DemoSlopeParityV2 extends DemoSimple<DemoSlopeParityV2Props, DemoSimpleState> implements IDemoView {\n    increasingTracker: SlopeParityHandler | undefined\n    decreasingTracker: SlopeParityHandler | undefined\n    private _inputFile: React.RefObject<HTMLInputElement>\n    private _increasingBuffer: ArrayBuffer | undefined\n    private _decreasingBuffer: ArrayBuffer | undefined\n\n    constructor(props: DemoSlopeParityV2Props) {\n        super(props)\n        this._inputFile = React.createRef()\n    }\n\n    public render() {\n        return (\n            <div>\n                <label htmlFor=\"input-upload-file\" aria-label=\"Choose file\">\n                    <Box component=\"div\" sx={{ p: 2, border: '2px dashed #aaa', mb: 2 }}>\n                        <Button component=\"label\">\n                            Upload notification for increasing\n                            <Input\n                                style={{ display: 'none' }}\n                                aria-hidden={true}\n                                ref={this._inputFile}\n                                type=\"file\"\n                                id=\"input-upload-file\"\n                                onChange={(e) => this._handleFileChange(e, 1)}\n                            />\n                        </Button>\n                    </Box>\n                </label>\n                <label htmlFor=\"input-upload-file\" aria-label=\"Choose file\">\n                    <Box component=\"div\" sx={{ p: 2, border: '2px dashed #aaa', mb: 2 }}>\n                        <Button component=\"label\">\n                            Upload notification for decreasing\n                            <Input\n                                style={{ display: 'none' }}\n                                aria-hidden={true}\n                                ref={this._inputFile}\n                                type=\"file\"\n                                id=\"input-upload-file\"\n                                onChange={(e) => this._handleFileChange(e, -1)}\n                            />\n                        </Button>\n                    </Box>\n                </label>\n            </div>\n        )\n    }\n\n    private _handleFileChange = (event: React.FormEvent<HTMLElement>, direction: number) => {\n        if (DEBUG) console.log('file changed!')\n        let target: any = event.target\n        if (target && target.files && target.files.length === 1) {\n            console.log(event)\n            let file: File = target.files[0]\n            // process file\n            file.arrayBuffer()\n                .then((buffer) => {\n                    // if (DEBUG) console.log(buffer.byteLength)\n                    // byte length is not 0 from console.log statements\n                    if (direction == 1) {\n                        this._increasingBuffer = buffer\n                    } else {\n                        this._decreasingBuffer = buffer\n                    }\n                    if (DEBUG) console.log('updated buffer for', direction)\n                })\n                .catch(console.error)\n        }\n    }\n\n    ////////// HELPER METHODS ///////////////\n    public initializeSink() {\n        this.sink = OutputEngine.getInstance().addSink('DemoSlopeParityV2')\n        this.increasingTracker = new SlopeParityHandler(1, new FileOutput(this._increasingBuffer))\n        this.decreasingTracker = new SlopeParityHandler(-1, new FileOutput(this._decreasingBuffer))\n        if (DEBUG) console.log('sink initialized')\n        this.sink.addDataHandler(this.increasingTracker)\n        this.sink.addDataHandler(this.decreasingTracker)\n        this.sink.addDataHandler(new NoteHandler(undefined, new NoteSonify()))\n        return this.sink\n    }\n}\n","import { OutputEngine } from '../sonification/OutputEngine'\n\nimport React, { ChangeEvent } from 'react'\n\nimport { OutputStateChange } from '../sonification/OutputConstants'\nimport { ImportView } from '../views/ImportView'\nimport { DataView } from '../views/DataView'\n\nimport { FormControl, InputLabel, Grid, NativeSelect } from '@mui/material'\n\nimport { DataManager } from '../DataManager'\n\nimport { IDemoView } from '../views/demos/IDemoView'\nimport { DemoSimple } from '../views/demos/DemoSimple'\nimport { DemoHighlightRegion } from '../views/demos/DemoHighlightRegion'\nimport { DemoSpeakRange } from '../views/demos/DemoSpeakRange'\nimport { DemoFileOutput } from '../views/demos/DemoFileOutput'\nimport { op } from 'arquero'\nimport { DemoSlopeParityV1 } from '../views/demos/DemoSlopeParityV1'\nimport { DemoSlopeParityV2 } from '../views/demos/DemoSlopeParityV2'\nimport { DemoRunningExtrema } from '../views/demos/DemoRunningExtrema'\nimport Table from 'arquero/dist/types/table/table'\n\nconst DEMO_VIEW_MAP = {\n    simple: { value: 'simple', label: 'Simple sonification', component: DemoSimple },\n    highlightRegion: { value: 'highlightRegion', label: 'Highlight points for region', component: DemoHighlightRegion },\n    speechHighlight: { value: 'speechHighlight', label: 'Speak points in range', component: DemoSpeakRange},\n    fileOutput: {value: 'fileOutput', label: 'Point of interest notification', component: DemoFileOutput},\n    slopeParityV1: {value: 'slopeParityV1', label: 'Slope direction change notification', component: DemoSlopeParityV1},\n    slopeParityV2: {value: 'slopeParityV2', label: 'Slope parity notification', component: DemoSlopeParityV2},\n    runningExtrema: {value: 'runningExtrema', label: 'Running extrema notification', component: DemoRunningExtrema}\n}\n\nlet demoViewRef: React.RefObject<DemoSimple<DemoProps, DemoState> | DemoHighlightRegion> = React.createRef()\nexport interface DemoState {\n    dataSummary: any\n    data: any\n    columnList: string[]\n    columnSelected: string\n    demoViewValue: string\n    playbackLabel: string\n}\n\nexport interface DemoProps {}\n\nexport class Demo extends React.Component<DemoProps, DemoState> {\n    constructor(props: DemoProps) {\n        super(props)\n        this.state = {\n            dataSummary: { min: 300, max: 500, median: 400, mean: 400, count: 200 },\n            data: undefined,\n            demoViewValue: 'simple',\n            playbackLabel: 'play',\n            columnSelected: 'Value',\n            columnList: ['Value'],\n        }\n\n        DataManager.getInstance().addListener(this._handleDataChange)\n        OutputEngine.getInstance().subscribe(this._handlePlaybackStateChanged)\n    }\n\n    public render() {\n        const { demoViewValue, dataSummary, playbackLabel, columnSelected, columnList } = this.state\n\n        const DemoComponent = DEMO_VIEW_MAP[demoViewValue].component\n\n        return (\n            <div>\n                <h1> basic sonification demo</h1>\n                <div>\n                    <ImportView />\n                </div>\n\n                <div style={{ marginTop: '20px' }}>\n                    <Grid container spacing={2}>\n                        <Grid item xs={8} sm={4} md={4}>\n                            <FormControl>\n                                <InputLabel variant=\"standard\" htmlFor=\"data-column-select\" id=\"data-column-label\">\n                                    Select Data Column\n                                </InputLabel>\n                                <NativeSelect\n                                    aria-label=\"Select data column to sonify\"\n                                    id=\"data-column-select\"\n                                    variant=\"standard\"\n                                    value={columnSelected}\n                                    onChange={this._handleColumnSelectChange}\n                                >\n                                    {columnList.map((column) => (\n                                        <option value={column} key={column}>\n                                            {column}\n                                        </option>\n                                    ))}\n                                </NativeSelect>\n                            </FormControl>\n                        </Grid>\n                        <Grid item xs={8} sm={4} md={4}>\n                            <FormControl>\n                                <InputLabel variant=\"standard\" htmlFor=\"demo-view-select\" id=\"demo-view-label\">\n                                    Sonification Demo\n                                </InputLabel>\n                                <NativeSelect\n                                    aria-label=\"Choose demo\"\n                                    id=\"demo-view-select\"\n                                    value={demoViewValue}\n                                    onChange={this._handleDemoViewValueChange}\n                                >\n                                    {Object.values(DEMO_VIEW_MAP).map((e) => (\n                                        <option value={e.value} key={e.value}>\n                                            {e.label}\n                                        </option>\n                                    ))}\n                                </NativeSelect>\n                            </FormControl>\n                        </Grid>\n                    </Grid>\n                </div>\n                <div style={{ marginTop: '20px' }}>\n                    {/* <textarea value={editorText}onChange={handleEditorChange}/>  */}\n                    {/* <Editor height=\"90vh\" defaultLanguage=\"javascript\" defaultValue={editorText} onChange={handleEditorChange} /> */}\n                    <Grid container spacing={2}>\n                        <Grid item xs={12} sm={8} md={8}>\n                            {<DemoComponent ref={demoViewRef} dataSummary={dataSummary} />}\n                        </Grid>\n                    </Grid>\n\n                    <button onClick={this._handlePlayButton}>{playbackLabel}</button>\n                    <p>\n                        Press the interrupt with random data button when a tone is playing to override what is playing\n                        with random data.\n                    </p>\n                </div>\n\n                <div>\n                    <DataView />\n                </div>\n            </div>\n        )\n    }\n\n    private _handleDataChange = (data: any) => {\n        // Get all column names\n        let columnList = data.columnNames(),\n            exampleRow = data.object()\n\n        if (columnList.length > 0 && exampleRow) {\n            // Filter out columns that are not numerical types\n            columnList = columnList.filter((column) => typeof exampleRow[column] === 'number')\n\n            if (columnList.length > 0) {\n                const columnSelected = columnList[0]\n                let dataSummary = this._computeDataSummary(data, columnSelected)\n\n                this.setState({\n                    dataSummary: dataSummary,\n                    data: data,\n                    columnList: columnList,\n                    columnSelected: columnSelected,\n                })\n            }\n        }\n    }\n\n    private _computeDataSummary = (data: any, columnSelected: string) => {\n        const dataSummary = data\n            .rollup({\n                mean: op.mean(columnSelected),\n                min: op.min(columnSelected),\n                max: op.max(columnSelected),\n                median: op.median(columnSelected),\n                count: op.count(),\n            })\n            .object()\n        return dataSummary\n    }\n\n    private _handlePlayButton = () => {\n        const outputEngineInstance = OutputEngine.getInstance()\n\n        let outputState = outputEngineInstance.value\n        console.log('Output Engine instance is present. Output state', outputState)\n\n        if (outputState == OutputStateChange.Pause) {\n            outputEngineInstance.next(OutputStateChange.Play)\n        } else if (outputState == OutputStateChange.Play) {\n            console.log('pausing output.')\n            outputEngineInstance.next(OutputStateChange.Pause)\n        } else {\n            let table = this.state.data as Table\n            console.log(`table: ${this.state.columnSelected} ${table} ${table.columnNames}`)\n\n            if (table) {\n                let column = table.array(this.state.columnSelected)\n                //console.log(`column ${column}`)\n\n                if (demoViewRef.current) {\n                    let demoView: IDemoView = demoViewRef.current\n                    console.log(\"calling demo's onPlay()\")\n                    demoView.onPlay(column)\n                }\n            }\n        }\n    }\n\n    private _handlePlaybackStateChanged = (e: OutputStateChange) => {\n        console.log('handlePlaybackStateChanged', OutputStateChange[e])\n        let playbackLabel\n        switch (e) {\n            case OutputStateChange.Play:\n                playbackLabel = 'pause'\n                break\n            case OutputStateChange.Pause:\n                playbackLabel = 'resume'\n                break\n            default:\n                playbackLabel = 'play'\n                break\n        }\n        this.setState({ playbackLabel: playbackLabel })\n\n        //console.log('returning. play button label', playbackLabel)\n    }\n\n    private _handleDemoViewValueChange = (event: ChangeEvent<HTMLSelectElement>) => {\n        let demoViewValue = event.target.value\n        this.setState({ demoViewValue: demoViewValue })\n    }\n\n    private _handleColumnSelectChange = (event: ChangeEvent<HTMLSelectElement>) => {\n        //console.log('change column selected', event.target.value)\n        const columnSelected = event.target.value\n\n        let table = this.state.data\n\n        if (table) {\n            // Hardcode getting the \"Value\" column from each data table, this will need to be set by user later\n            const dataSummary = this._computeDataSummary(table, columnSelected)\n            this.setState({ columnSelected: columnSelected, dataSummary: dataSummary })\n        }\n    }\n}\n","import React from 'react'\n\nimport { TextField } from '@mui/material'\nimport { IDemoView } from './IDemoView'\nimport { RunningExtremaHandler } from '../../sonification/handler/RunningExtremaHandler'\nimport { DemoSimple, DemoSimpleProps, DemoSimpleState } from './DemoSimple'\nimport { NoteHandler } from '../../sonification/handler/NoteHandler'\nimport { OutputEngine } from '../../sonification/OutputEngine'\nimport { Box, Button, Input } from '@mui/material'\nimport { Speech } from '../../sonification/output/Speech'\nimport { NoteSonify } from '../../sonification/output/NoteSonify'\n\nconst DEBUG = true\n\nexport interface DemoRunningExtremaProps extends DemoSimpleProps {\n    dataSummary: any\n}\n\nexport class DemoRunningExtrema\n    extends DemoSimple<DemoRunningExtremaProps, DemoSimpleState>\n    implements IDemoView\n{\n    minimumTracker: RunningExtremaHandler | undefined\n    maximumTracker: RunningExtremaHandler | undefined\n\n    constructor(props: DemoRunningExtremaProps) {\n        super(props)\n    }\n\n    ////////// HELPER METHODS ///////////////\n    public initializeSink() {\n        this.sink = OutputEngine.getInstance().addSink('DemoSlopeParity')\n        this.maximumTracker = new RunningExtremaHandler(1, new Speech())\n        this.minimumTracker = new RunningExtremaHandler(-1, new Speech())\n        if (DEBUG) console.log(\"sink initialized\")\n        this.sink.addDataHandler(this.maximumTracker)\n        this.sink.addDataHandler(this.minimumTracker)\n        this.sink.addDataHandler(new NoteHandler(undefined, new NoteSonify()))\n        return this.sink\n    }\n}\n","import React, { FC } from 'react'\nimport { Link } from 'react-router-dom'\n\nconst Index: FC = (props) => {\n    const opts = [\n        { name: 'Basic', url: '/basic' },\n        { name: 'Jacdac', url: '/jacdac' },\n        { name: 'Jacdac and microbit', url: '/jacdacmicrobit' },\n        { name: 'Dashboard', url: '/dashboard' },\n    ]\n\n    return (\n        <>\n            <ul>\n                {opts.map((opt) => (\n                    <li>\n                        <Link to={opt.url}>{opt.name}</Link>\n                    </li>\n                ))}\n            </ul>\n        </>\n    )\n}\n\nexport default Index\n","import React, { lazy, Suspense } from 'react'\nimport ReactDOM from 'react-dom'\nimport { Demo } from './pages/Demo'\nconst Jacdac = lazy(() => import('./pages/Jacdac'))\nconst Dashboard = lazy(() => import('./pages/Dashboard'))\nconst MicrobitController = lazy(() => import('./pages/MicrobitController'))\n\nimport { BrowserRouter, Routes, Route } from 'react-router-dom'\nimport Index from './pages/Index'\n\nif (module.hot) {\n    module.hot.accept()\n}\n\nReactDOM.render(\n    <BrowserRouter>\n        <Routes>\n            <Route path=\"/\" element={<Index />} />\n            <Route path=\"basic\" element={<Demo />} />\n            <Route\n                path=\"jacdac\"\n                element={\n                    <Suspense fallback={null}>\n                        <Jacdac />\n                    </Suspense>\n                }\n            />\n            <Route\n                path=\"jacdacmicrobit\"\n                element={\n                    <Suspense fallback={null}>\n                        <MicrobitController />\n                    </Suspense>\n                }\n            />\n            <Route\n                path=\"dashboard\"\n                element={\n                    <Suspense fallback={null}>\n                        <Dashboard />\n                    </Suspense>\n                }\n            />\n        </Routes>\n    </BrowserRouter>,\n    document.getElementById('root'),\n)\n","import * as d3 from 'd3'\n\n/**\n * The base interface for a data point. This is an interface because data points\n * may be used in other settings as well and we don't want to be too strict about what they are.\n *\n * All data points have certain properties and abilities, however\n * @field value The raw data value associated with this point\n * @field adjustedValue An adjusted value that may be assigned to a point for output.\n * @field previous The previous point in the sequence for this sink\n * @method toString() Returns a string describing this data point\n * @field sink The data sink this point is associated with [not sure if we need this pointer, but for completeness...]\n */\n\nexport class Datum {\n    value: number\n    sinkId: number\n    time: number\n\n    constructor(sinkId: number, value: number, time?: number) {\n        this.value = value\n        this.sinkId = sinkId\n        if (time) this.time = time\n        else this.time = d3.now()\n    }\n\n    public toString(): string {\n        return `(raw: ${this.value}, ${this.time})`\n    }\n}\n","import { map, Observable, tap, Subject } from 'rxjs'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from './OutputConstants'\nimport { DataHandler } from './handler/DataHandler'\n\n\nconst DEBUG = false\n\n\n/**\n * The DataSink for a stream of data\n */\nexport class DataSink extends Subject<OutputStateChange | Datum> {\n    //////////////////////////////// FIELDS ///////////////////////////////////\n\n    /**\n     * A unique id for this DataSink\n     */\n    public id: number\n\n    /**\n     * A description of this DataSink for documentation\n     */\n    private _description: String\n\n    //////////////////////////////// HANDLERS ///////////////////////////////////\n    /**\n     * A list of DataHandlers. DataHandlers are passed each new Datum when it arrives.\n     */\n    private _dataHandlers: Array<DataHandler>\n    overrideDatum: boolean\n    public removeDataHandler(dataHandler: DataHandler) {\n        dataHandler.complete()\n        this._dataHandlers = this._dataHandlers.filter((dataHandler) => dataHandler !== dataHandler)\n    }\n    public addDataHandler(dataHandler: DataHandler) {\n        debugStatic(SonificationLoggingLevel.DEBUG,`Adding data handeler: ${dataHandler}. length of _handelers of sink is ${this._dataHandlers.length}`)\n        let observable = this as Observable<OutputStateChange | Datum>\n\n        if(this.overrideDatum) {\n            if (this._dataHandlers.length > 0)\n                observable = this._dataHandlers[this._dataHandlers.length - 1] as Observable<OutputStateChange | Datum>\n        }\n\n\n        debugStatic(SonificationLoggingLevel.DEBUG, `printing ${observable}`)\n        dataHandler.setupSubscription(observable)\n        this._dataHandlers.push(dataHandler)\n    }\n\n    //////////////////////////////// CONSTRUCTOR ///////////////////////////////////\n\n    /**\n     * Instantiate a DataSink\n     * @param id A unique ID for the DataSink\n     * @param description A description for the DataSink\n     */\n\n    constructor(id: number, description: String,overrideDatum:boolean = false) {\n\n        super()\n        this.id = id\n        this._description = description\n        this._dataHandlers = new Array<DataHandler>()\n\n        this.overrideDatum = overrideDatum\n\n    }\n\n    //////////////////////////////// HELPER METHODS ///////////////////////////////////\n    /**\n     * Subscribe to the OutputEngine (override to modify or filter the stream in some way)\n     *\n     * @param engine$ An Output's stream of Datum comes from a DataHandlar\n     */\n    public setupSubscription(statedatum$: Observable<OutputStateChange | Datum>) {\n        statedatum$\n            .pipe(\n                map((val) => {\n                    if (val instanceof Datum) val.sinkId = this.id\n\n                    return val\n                }),\n\n                debug(SonificationLoggingLevel.DEBUG, `dataSink`, DEBUG),\n\n            )\n            .subscribe(this)\n    }\n\n    public toString() {\n        let description = this._description\n        description += `(id: ${this.id})`\n        return description\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nimport { Datum } from './Datum'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(tag(message))\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } //else console.log('debug message dumped')\n    }\n\n}\n","import { Datum } from './Datum'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from './OutputConstants'\nimport { DataSink } from './DataSink'\nimport { BehaviorSubject, distinctUntilChanged, map, merge, Observable, shareReplay, tap } from 'rxjs'\nimport assert from 'assert'\nimport { create } from 'rxjs-spy'\n\nconst DEBUG = false\n\n/**\n * OutputEngine class\n * Has a single instance\n * Users of our library get an instance of this to control it i.e. get sink, play, etc.\n */\nexport class OutputEngine extends BehaviorSubject<OutputStateChange> {\n    public spy = create()\n\n    /**\n     * The Output Engine. Enforce that there is only ever one.\n     * @todo ask group if there is a better way to enforce this.\n     */\n    private static outputEngineInstance: OutputEngine\n\n    /**\n     * A map of Data sinks handled by the Output Engine.\n     */\n    private sinks: Map<\n        number,\n        {\n            sink: DataSink\n            stream$: Observable<OutputStateChange | Datum> | undefined\n        }\n    >\n\n    /**\n     * @returns A dataSink Id that is unique\n     */\n    public getUniqueId(): number {\n        let newId = 0\n        this.sinks.forEach((value, key) => {\n            newId = key > newId ? key : newId\n        })\n        return newId + 1\n    }\n\n    /**\n     * Get a sink given an Id. Throws an error of sinkId doesn't exist.\n     * @param sinkId\n     * @returns Returns the DataSink associated with sinkId.\n     */\n    public getSink(sinkId: number): DataSink {\n        let sink = this.sinks.get(sinkId)?.sink\n        assert(sink, `no sink associated with ${sinkId}`)\n        return sink\n    }\n\n    /**\n     * AddSink takes optional arguments, and based on what is provided either constructs\n     * a new data sink or uses a given one. In either case, it adds it to the set of sinks.\n     *\n     * @param description A description for the sink\n     * @param sinkId A unique id for the sink\n     * @param sink The DataSink object\n     */\n    public addSink(description?: string, sinkId?: number, sink?: DataSink, stream$?: Observable<Datum>): DataSink {\n        description = description ? description : 'Unknown Sink'\n        sinkId = sink ? sink.id : sinkId\n        if (!sinkId) sinkId = this.getUniqueId()\n        assert(!this.sinks.has(sinkId), 'sinkId is not unique')\n        sink = sink ? sink : new DataSink(sinkId, description)\n        assert(sink?.id == sinkId, \"sinkId and sink.id don't match\")\n        this.sinks.set(sinkId, { sink: sink, stream$: undefined })\n        if (stream$) this.setStream(sinkId, stream$)\n        return sink\n    }\n\n    /**\n     * Removes a data sink. Once removed, that Id may be re-used.\n     * @param sinkId Data sink to remove.\n     */\n    public deleteSink(sink?: DataSink, sinkId?: number) {\n        sink = sinkId ? this.sinks.get(sinkId)?.sink : sink\n        sink?.complete()\n        if (sink) {\n            this.sinks.delete(sink.id)\n        }\n\n        if (!sink && !sinkId) throw Error('Must specify sink or ID')\n    }\n\n    /**\n     * @deprecated\n     *\n     * pushPoint is sort of legacy. It feeds data in to the sink by calling\n     * sink.next(). However this should not be used as things like automatic\n     * calls to complete() when the stream ends break when you use this approach.\n     *\n     * @param x A number\n     * @param sinkId Which sink it should go to\n     */\n    pushPoint(x: number, sinkId: number) {\n        let sink = this.getSink(sinkId)\n        sink.next(new Datum(sinkId, x))\n    }\n\n    /////////////////// STREAM SUPPORT /////////////////////////////////\n\n    /**\n     * Sets up the stream and/or hot swaps this stream\n     * for another.\n     *\n     * Makes sure that the stream replaces SWAP events with the\n     * correct Play/Pause event and doesn't ever repeat the same state\n     *\n     * @todo should we disable hot swapping?\n     * @param data$ an observable stream of Datum\n     */\n    public setStream(sinkId: number, data$: Observable<Datum>) {\n        debugStatic(SonificationLoggingLevel.DEBUG, `Setting Stream: ${sinkId}`)\n        let res = this.sinks.get(sinkId)\n        if (!res) return\n        if (res.stream$) res?.sink?.complete()\n        let sink = res.sink\n\n        data$.subscribe({\n            complete: () => {\n                this.next(OutputStateChange.Stop)\n                sink.complete()\n                this.deleteSink(sink)\n            },\n        })\n\n        let filteredState$ = this.pipe(\n            map((state) => {\n                switch (state) {\n                    case OutputStateChange.Swap:\n                        {\n                            debugStatic(SonificationLoggingLevel.DEBUG, 'Swapping Play and Pause')\n                            if (this.value == OutputStateChange.Pause) return OutputStateChange.Play\n                            else if (this.value == OutputStateChange.Play) return OutputStateChange.Pause\n                            else Error('can only swap Play and Pause')\n                        }\n                        return state\n                    default:\n                        debugStatic(SonificationLoggingLevel.DEBUG, `state changed to ${OutputStateChange[state]}`)\n                        return state\n                }\n            }),\n            // distinctUntilChanged(),\n            // shareReplay doesn't seem to work as expected\n            // only works for adding new sinks to the chain\n            // does not update OutputStateChange for newly added handlers or outputs\n            shareReplay(1),\n        )\n        let combined$ = merge(filteredState$, data$)\n\n        sink.setupSubscription(combined$)\n\n        this.sinks.set(sink.id, {\n            sink: sink,\n            stream$: combined$,\n        })\n    }\n\n    ////////////////// CONSTRUCTOR /////////////////////////////////////\n    /**\n     * Set up the output board. set up maps needed to keep track of sinks and outputs.\n     *\n     * Also turns this into a \"hot\" stream\n     */\n    private constructor() {\n        super(OutputStateChange.Undefined)\n        this.sinks = new Map()\n        this.spy.show()\n        this.spy.log()\n    }\n\n    /**\n     * Create a new OutputEngine. Enforces that there is only ever one\n     * @returns The OutputEngine's instance..\n     */\n    public static getInstance(): OutputEngine {\n        if (!OutputEngine.outputEngineInstance) {\n            OutputEngine.outputEngineInstance = new OutputEngine()\n        }\n\n        return OutputEngine.outputEngineInstance\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\n\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(tag(message))\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } //else console.log('debug message dumped')\n    }\n}\n","import { Datum } from '../Datum'\nimport { getSonificationLoggingLevel, SonificationLoggingLevel } from '../OutputConstants'\nimport { Sonify } from './Sonify'\nimport { Observable, tap } from 'rxjs'\n\nconst DEBUG = false\n\n/**\n * Class for sonifying a data point as a pitch.\n * @extends Sonify\n *\n * @field smooth: Should the note smoothly transition from the pitch of the previous data point?\n *\n * [note may want to think about whether supporting cohices for different animations besides linearRampToValueAtTime]\n * [note implementation not complete. Needs to handle scheduleSound still]\n */\nexport class NoteSonify extends Sonify {\n    /**\n     * Stop all notes. This tells the oscillator to stop playing.\n     */\n    protected stop() {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'Stopping Playback')\n        let oscillator = this.outputNode as OscillatorNode\n        // Need to prevent calling stop on OscillatorNode if start() is never called\n        // For now use a try catch to handle the error\n        try {\n            oscillator?.stop()\n        } catch (e) {\n            console.log(e)\n        }\n        super.stop()\n    }\n\n    /**\n     * Start playing the current datum. This starts the oscillator again.\n     */\n    protected start() {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'starting oscillator')\n        let oscillator = this.outputNode as OscillatorNode\n        if (!this.isAudioPlaying) {\n            oscillator.start()\n            this.isAudioPlaying = true\n        }\n        super.start()\n    }\n\n    /**\n     * Show the output\n     */\n    protected output(datum: Datum) {\n        debugStatic(SonificationLoggingLevel.DEBUG, `outputing ${datum.value} to oscillator`)\n        let oscillator = this.outputNode as OscillatorNode\n\n        oscillator.frequency.value = datum.value\n    }\n\n    /**\n     * Generates a new note sonifier\n     */\n    public constructor(pan: number = 0) {\n        super(Sonify.audioCtx.createOscillator(), pan)\n\n        let oscillator = this.outputNode as OscillatorNode\n        if (oscillator == undefined) {\n            debugStatic(SonificationLoggingLevel.DEBUG, 'creating oscillator')\n            oscillator = Sonify.audioCtx.createOscillator()\n            this.outputNode = oscillator\n        }\n    }\n\n    /**\n     *\n     * @returns A string describing the current frequency being played.\n     */\n    public toString(): string {\n        let oscillator = this.outputNode as OscillatorNode\n        if (oscillator) return `NoteSonify playing ${oscillator.frequency.value}`\n        else return `NoteSonify not currently playing`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } //else console.log('debug message dumped')\n    }\n}\n","import { BehaviorSubject, filter, map, Observable, of, Subscription } from 'rxjs'\nimport { Datum } from '../Datum'\nimport { OutputStateChange } from '../OutputConstants'\n\n/**\n * Base class for calculating a statistic for a data stream.\n *\n * @todo should stats watch StateDatum streams or num streams?\n *\n * Stores the last  value of the statistic\n */\nexport class Statistic extends BehaviorSubject<number> {\n    constructor(value: number, stream$?: Observable<OutputStateChange | Datum>) {\n        super(value)\n        if (stream$) {\n            this.setupSubscription(\n                stream$.pipe(\n                    filter((val) => val instanceof Datum),\n                    map((val) => {\n                        let datum = val as Datum\n                        return datum.value\n                    }),\n                ),\n            )\n        } else {\n            let singlePoint$ = of(value)\n            //let singleState$ = of(OutputState.Undefined)\n            //combineLatest({ state: singleState$, datum: singlePoint$ })\n            this.setupSubscription(singlePoint$)\n        }\n    }\n\n    subscription?: Subscription\n\n    /**\n     * Sets up a subscription that only updates when new values come in\n     *\n     * @param stream$ The data being streamed\n     */\n    public setupSubscription(stream$: Observable<number>): Subscription {\n        this.subscription?.unsubscribe()\n        this.subscription = stream$.subscribe(this)\n        return this.subscription\n    }\n\n    public toString() {\n        return `${this.value}$`\n    }\n}\n","import { distinctUntilChanged, filter, Observable, reduce, Subscription } from 'rxjs'\nimport { Datum } from '../Datum'\nimport { GrowthDirection, OutputStateChange } from '../OutputConstants'\nimport { Statistic } from './Statistic'\n\n/**\n * Keeps track of the end of a range for a data set\n */\nexport class RangeEndExpander extends Statistic {\n    direction: GrowthDirection\n\n    /**\n     * Set up a dynamic range end statistic.\n     *\n     * @param val the value to initialize the range with\n     * @param direction Whether we are expanding on the minimum or maximum end of the range\n     * @param stream$\n     * @param startVal\n     */\n    constructor(direction: GrowthDirection, stream$: Observable<OutputStateChange | Datum>, val?: number) {\n        super(val ? val : 0, stream$)\n        this.direction = direction\n    }\n\n    /**\n     * Uses reduce to decide whether to replace the value or not\n     * and uniqueUntilChange to only send updates when there is a new value\n     *\n     * @param stream$ the stream of data\n     * @returns a subscription\n     */\n    public setupSubscription(stream$: Observable<number>): Subscription {\n        return super.setupSubscription(\n            stream$.pipe(\n                reduce((acc, curr) => {\n                    if (this.direction == GrowthDirection.Min) {\n                        return curr >= acc ? acc : curr\n                    } else {\n                        return curr <= acc ? acc : curr\n                    }\n                }),\n                distinctUntilChanged(),\n            ),\n        )\n    }\n}\n","import { Datum } from '../Datum'\nimport { DataHandler } from './DataHandler'\nimport { DatumOutput } from '../output/DatumOutput'\nimport { map, Observable, tap, filter } from 'rxjs'\nimport { Statistic } from '../stat/Statistic'\nimport {\n    getSonificationLoggingLevel,\n    GrowthDirection,\n    OutputStateChange,\n    SonificationLoggingLevel,\n} from '../OutputConstants'\nimport { RangeEndExpander } from '../stat/RangeEndExpander'\nimport assert from 'assert'\n\n\nconst DEBUG = false\n\n\n\n/**\n * A DataHandler that scales the given value based on a specified min and max\n *\n * Scaling depends on also knowing the range of the data being provided. This DataHandler\n * takes as input an expected range, and a boolean value that specifies whether it should\n * (10 expand the range (2) throw an error or (3) cap the range if data appears that is not within range.\n */\nexport class ScaleHandler extends DataHandler {\n    /**\n     * The range that numbers should be scaled to (in order of min, max)\n     */\n    range: [Statistic, Statistic]\n    /**\n     * The range that numbers are expected to come from (in order of min, max)\n     */\n    domain: [Statistic, Statistic]\n\n    /**\n     * Converts from domain to target range.\n     */\n    private _conversionFunction: (value: number, domain: [number, number], range: [number, number]) => number\n    protected get conversionFunction(): (value: number, domain: [number, number], range: [number, number]) => number {\n        return this._conversionFunction\n    }\n    protected set conversionFunction(\n        value: (value: number, domain: [number, number], range: [number, number]) => number,\n    ) {\n        this._conversionFunction = value\n    }\n\n    /**\n     * Sets up ranges for calculation. Will use expanding ranges based on stream if nothing is specified.\n     * @todo need to debug/ensure that exceedDomain is correctly processed in constructor & write test for this...\n     *\n     * @param conversionFunction defaults to a linear mapping.\n     * @param domain  The minimum and maximum of the domain (the range of the data coming in).\n     * @param targetRange The minimum and maximum of the target range (the adjusted data range).\n     * @param output\n     */\n    constructor(\n        conversionFunction?: (value: number, domain: [number, number], range: [number, number]) => number,\n        domain?: [number, number],\n        targetRange?: [number, number],\n        output?: DatumOutput,\n    ) {\n        super(output)\n\n        if (conversionFunction) this._conversionFunction = conversionFunction\n        else {\n            this._conversionFunction = (num: number, domain: [number, number], range: [number, number]) => {\n                let res = ((num - domain[0]) * (range[1] - range[0])) / (domain[1] - domain[0]) + range[0]\n                return (res = NaN) ? 0 : res\n            }\n        }\n\n        if (domain) {\n            assert(domain[0] < domain[1], 'Domain should be in order of min, max')\n            // add a stat for the min\n            this.domain = [new Statistic(domain[0]), new Statistic(domain[1])]\n        } else {\n            this.domain = [\n                new RangeEndExpander(GrowthDirection.Min, this, 0),\n                new RangeEndExpander(GrowthDirection.Max, this, 1),\n            ]\n        }\n\n        if (targetRange) {\n            assert(targetRange[0] < targetRange[1], 'range should be in order of min, max')\n            this.range = [new Statistic(targetRange[0]), new Statistic(targetRange[1])]\n        } else {\n            this.range = [\n                new RangeEndExpander(GrowthDirection.Min, this, 0),\n                new RangeEndExpander(GrowthDirection.Max, this, 1),\n            ]\n        }\n    }\n\n    /**\n     * Subcribes to a modified version the sink which replaces the original datum with a scaled datum\n     *\n     * @param sink$ The data comes from here\n     */\n    public setupSubscription(sink$: Observable<OutputStateChange | Datum>): void {\n        super.setupSubscription(\n            sink$.pipe(\n                map((val) => {\n                    if (val instanceof Datum) {\n                        let datum = new Datum(\n                            val.sinkId,\n                            this.conversionFunction(\n                                val.value,\n                                [this.domain[0].value, this.domain[1].value],\n                                [this.range[0].value, this.range[1].value],\n                            ),\n                            val.time,\n                        )\n                        return datum\n                    } else return val\n                }),\n\n                debug(SonificationLoggingLevel.DEBUG, 'scaled', DEBUG),\n\n            ),\n        )\n    }\n\n    public toString(): string {\n        return `ScaleHandler: Converting from ${this.domain[0]}, ${this.domain[1]} to ${this.range[0]},${this.range[1]}`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } //else console.log('debug message dumped')\n    }\n\n}\n","import { DatumOutput } from '../output/DatumOutput'\nimport { ScaleHandler } from './ScaleHandler'\n/**\n * A DataHandler that outputs a Datum as a note in the audible range.\n * Assumes a note should be played in the general range of 80 to 500 Hz to sound nice\n */\nexport class NoteHandler extends ScaleHandler {\n    /**\n     * Sets up a default target range that is audible. Uses the Mel Scale (https://www.wikiwand.com/en/Mel_scale)\n     * @param sink. DataSink that is providing data to this Handler.\n     * @param targetRange The audible range the note should be in\n     * @param volume How loudly to play the note.\n     */\n\n    constructor(domain?: [number, number], output?: DatumOutput) {\n        super(NoteHandler.melConversion, domain, [80, 450], output)\n    }\n\n    public static melConversion(num, domain, range): number {\n        let positiveVal = ((num - domain[0]) * (range[1] - range[0])) / (domain[1] - domain[0]) + range[0]\n        let frequency = 700 * (Math.exp(positiveVal / 1127) - 1)\n        if (frequency == NaN || frequency == undefined) frequency = range[1]\n        return frequency\n    }\n\n    public toString(): string {\n        return `NoteHandler: Converting using Mel from ${this.domain[0]}, ${this.domain[1]} to ${this.range[0]},${this.range[1]}`\n    }\n}\n","import { DatumOutput } from '../output/DatumOutput'\nimport { filter, Observable, Subject, Subscription, tap } from 'rxjs'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from '../OutputConstants'\n\nconst DEBUG = false\n\n/**\n * A DataHandler class is used to decide how to output each data point.\n */\nexport abstract class DataHandler extends Subject<OutputStateChange | Datum> {\n    \n    private subscription?: Subscription\n    private _outputs: Array<DatumOutput>\n\n    /**\n     * Add an output and make sure it has the right subscriptions\n     *\n     * @param output The output to add\n     */\n    public addOutput(output: DatumOutput) {\n        this.setupOutputSubscription(output)\n        this._outputs.push(output)\n    }\n\n    /**\n     * \n     * @param output \n     */\n    public removeOutput(output: DatumOutput) {\n        this._outputs = this._outputs.filter((o) => o !== output)\n        output.complete()\n    }\n\n    /**\n     * Set up a subscription so we are notified about events\n     * Override this if the data needs to be modified in some way\n     *\n     * @param sink The sink that is producing data for us\n     */\n    public setupSubscription(sink$: Observable<OutputStateChange | Datum>) {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'setting up subscription for sink')\n        this.subscription = sink$.pipe(debug(SonificationLoggingLevel.DEBUG, 'DataHandler', DEBUG)).subscribe(this)\n    }\n\n    /**\n     * Call output.setupSubscription, possibly modify stream before sending to output.\n     *\n     * @param output The output object\n     */\n    setupOutputSubscription(output: DatumOutput) {\n        let outputStream$ = this.pipe(filter((val) => val != undefined))\n        debugStatic(SonificationLoggingLevel.DEBUG, 'setting up output')\n        output.setupSubscription(outputStream$ as Observable<OutputStateChange | Datum>)\n    }\n    public toString(): string {\n        return `DataHandler ${this}`\n    }\n\n    /**\n     * Remove all subscriptions\n     */\n    complete(): void {\n        this.subscription?.unsubscribe()\n        this._outputs.forEach((output) => output.complete())\n        super.complete()\n    }\n\n    /**\n     * @param output An optional way to output the data\n     */\n    constructor(output?: DatumOutput) {\n        super()\n        this._outputs = new Array<DatumOutput>()\n        if (output) this.addOutput(output)\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nimport { Datum } from '../Datum'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + (val instanceof Datum) ? val : OutputStateChange[val])\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } else console.log('debug message dumped')\n    }\n}\n","import assert from 'assert'\nimport { filter, Observable, tap } from 'rxjs'\nimport { getSonificationLoggingLevel, OutputStateChange, SonificationLoggingLevel } from '../OutputConstants'\nimport { DatumOutput } from './DatumOutput'\n\n\nconst DEBUG =  false\n\n\n/**\n * Base class for sonifying a datum. Abstract -- must be subclassed to be fully defined\n * @field volume Presuming here than anything you play would have a volume.\n * @todo how is this combined with priority for datum; and global volume?]\n * @field datum The raw data used to generate this sonification type\n */\nexport class Sonify extends DatumOutput {\n    /**\n     * Every output that extends this needs an audio context used to play sounds.\n     * Sonify will keep control of that audio context and ensure that only 1 audio context exists.\n     */\n    private static _audioCtx = new AudioContext()\n    private _stereoPannerNode: StereoPannerNode\n    public get stereoPannerNode(): StereoPannerNode {\n        return this._stereoPannerNode\n    }\n    public  set stereoPannerNode(value: StereoPannerNode) {\n        this._stereoPannerNode = value\n    }\n    public static get audioCtx(): AudioContext {\n        return Sonify._audioCtx\n    }\n    private _gainNode: GainNode\n    public get gainNode(): GainNode {\n        return this._gainNode\n    }\n    public set gainNode(value: GainNode) {\n        this._gainNode = value\n    }\n\n    /**\n     * The volume a sound will be played at\n     */\n    protected _volume: number = 5\n    public get volume(): number {\n        return this._volume\n    }\n    public set volume(value: number) {\n        this._volume = value\n    }\n\n    /**\n     * An audio node that must be configured to play this sound\n     */\n    protected _outputNode: AudioNode | undefined\n    protected get outputNode(): AudioNode | undefined {\n        return this._outputNode\n    }\n    protected set outputNode(value: AudioNode | undefined) {\n        this._outputNode = value\n    }\n\n    /**\n     * a boolean to keep track whether the oscillator node is playing.\n     * We need this to start the oscillator only when it sees the first datum.\n     */\n    protected isAudioPlaying: boolean\n\n    /**\n     * Stop all output. Stream has ended.\n     */\n    protected stop() {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'Stopping Playback')\n        this.outputNode?.disconnect()\n        this.isAudioPlaying = false;\n        super.stop()\n    }\n\n    /**\n     * Connects the oscillator node so that playback will resume.\n     */\n    protected start() {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'Starting')\n        Sonify.audioCtx.resume()\n        this.gainNode.connect(Sonify.audioCtx.destination)\n        this.stereoPannerNode.connect(this.gainNode)\n        this.outputNode?.connect(this.stereoPannerNode)\n        super.start()\n    }\n\n    /**\n     * Pauses playback\n     */\n    protected pause() {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'Pausing. Playback state is paused')\n        Sonify.audioCtx.suspend()\n        // Sonify.gainNode.disconnect()\n        super.pause()\n    }\n\n    /**\n     * Resumes playback\n     */\n    protected resume() {\n        debugStatic(SonificationLoggingLevel.DEBUG, 'Resuming. Playback state is resumed')\n        Sonify.audioCtx.resume()\n\n        // this.gainNode.connect(Sonify.audioCtx.destination)\n        // this.outputNode?.connect(this.gainNode)\n\n        super.resume()\n    }\n\n    /**\n     * Must be overriden. Generates a new instance of a SonificationType from a datum.\n     *\n     * @param volume The volume the sound should play at\n     * @param optionally include an audio node that can be played\n     * @returns Returns an instance of specific subclass of SonificationType.\n     */\n    constructor(audioNode?: AudioScheduledSourceNode,pan:number = 0) {\n        super()\n\n        if (!this.outputNode) this.outputNode = audioNode\n         this._gainNode = Sonify._audioCtx.createGain()\n         this._stereoPannerNode = Sonify._audioCtx.createStereoPanner()\n        this.stereoPannerNode.pan.value = pan\n        this.isAudioPlaying = false\n    }\n    /// TODO: Possible additional values\n    /// @param duration The length of time over which to change to the new pitch. Defaults to 10 ms\n    /// @param volume The volume to play the note at. Can be overriden globally\n    /// @param smooth Whether to connect the notes in the sequence being played. If undefined, defaults to true.\n\n    /**\n     *\n     * @returns A string representing this object.\n     */\n    public toString(): string {\n        return `Sonify`\n    }\n}\n\n//////////// DEBUGGING //////////////////\nimport { tag } from 'rxjs-spy/operators/tag'\nconst debug = (level: number, message: string, watch: boolean) => (source: Observable<any>) => {\n    if (watch) {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n            tag(message),\n        )\n    } else {\n        return source.pipe(\n            tap((val) => {\n                debugStatic(level, message + ': ' + val)\n            }),\n        )\n    }\n}\n\nconst debugStatic = (level: number, message: string) => {\n\n    if (DEBUG) {\n        if (level >= getSonificationLoggingLevel()) {\n            console.log(message)\n        } //else console.log('debug message dumped')\n    }\n\n}\n","import { Datum } from '../Datum'\nimport { SonifyFixedDuration } from './SonifyFixedDuration'\n\n/**\n * Class for sonifying a data point using an array buffer.\n * @extends SonifyFixedDuration\n */\nexport class FileOutput extends SonifyFixedDuration {\n    private _buffer: ArrayBuffer | undefined\n\n    constructor(buffer?: ArrayBuffer) {\n        super()\n        if (buffer) {\n            this._buffer = buffer\n        }\n    }\n\n    public get buffer(): ArrayBuffer | undefined {\n        return this._buffer\n    }\n\n    public set buffer(value: ArrayBuffer | undefined) {\n        this._buffer = value\n    }\n\n    // Create the buffer source and start it playing.\n    protected create(datum: Datum): AudioScheduledSourceNode {\n        console.log('playing for datum', datum.value)\n        const source = FileOutput.audioCtx.createBufferSource()\n        if (this._buffer) {\n            FileOutput.audioCtx.decodeAudioData(this._buffer.slice(0), (buffer) => (source.buffer = buffer))\n            this.outputNode = source\n            this.outputNode.connect(this.gainNode)\n            source.start()\n        }\n        if (source.buffer) this.duration = source.buffer.duration\n        return source\n    }\n\n    protected extend(timeAdd: number) {\n        throw new Error('Method not implemented.')\n    }\n}\n"],"sourceRoot":""}