{"version":3,"sources":["bus.ts","pages/Jacdac.tsx"],"names":["bus","createWebBus","filterNullish","pipe","filter","x","ConnectButton","useBus","connected","useChange","_","services","useServices","serviceClass","SRV_ACCELEROMETER","useState","streaming","setStreaming","xSink","setXSink","ySink","setYSink","zSink","setZSink","xAxisStream","setXAxisStream","yAxisStream","setYAxisStream","zAxisStream","setZAxisStream","useEffect","inIFrame","window","location","hash","startDevTools","length","accelService","console","log","specification","unsubs","readingRegister","subscribe","REPORT_UPDATE","throttle","a","unpackedValue","next","Datum","id","handleConnect","disconnect","connect","onClick","xSinkID","ySinkID","zSinkID","srcX","srcY","srcZ","OutputEngine","getInstance","OutputStateChange","Stop","addSink","addDataHandler","NoteHandler","NoteSonify","SlopeParityHandler","Speech","sourceX","Subject","setStream","sourceY","sourceZ","Play","disabled","Page","initialBus"],"mappings":"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","file":"static/js/6.fe60a42d.chunk.js","sourcesContent":["import { createWebBus } from 'jacdac-ts'\n\nexport const bus = createWebBus()\n","import React, { FC, useState, useEffect } from 'react'\n// import ConnectButton from \"../../jacdac-docs/src/components/buttons/ConnectButton\"\n\n// import { JDBus } from \"jacdac-ts/src/jdom/bus\"\n\nimport { SRV_ACCELEROMETER, REPORT_UPDATE, throttle, startDevTools, inIFrame } from 'jacdac-ts'\nimport { useServices, useChange, useBus } from 'react-jacdac'\nimport { Button } from '@mui/material'\nimport { OutputEngine } from '../sonification/OutputEngine'\nimport { JacdacProvider } from 'react-jacdac'\nimport { bus } from '../bus'\nimport { DataSink } from '../sonification/DataSink'\nimport { NoteHandler } from '../sonification/handler/NoteHandler'\nimport { OutputStateChange } from '../sonification/OutputConstants'\nimport { filter, Observable, OperatorFunction, pipe, Subject, UnaryFunction } from 'rxjs'\nimport { Datum } from '../sonification/Datum'\nimport { RunningExtremaHandler } from '../sonification/handler/RunningExtremaHandler'\nimport { SlopeParityHandler } from '../sonification/handler/SlopeParityHandler'\nimport { Speech } from '../sonification/output/Speech'\nimport { NoteSonify } from '../sonification/output/NoteSonify'\n\nconst TONE_THROTTLE = 100\n\n/**\n * helper function to filter out null values from subjects, and create an observable<Datum> for the sink to subscribe.\n * Source: https://stackoverflow.com/questions/57999777/filter-undefined-from-rxjs-observable\n * @returns observable <datum>\n */\n\nfunction filterNullish<T>(): UnaryFunction<Observable<T | null | undefined>, Observable<T>> {\n    return pipe(filter((x) => x != null) as OperatorFunction<T | null | undefined, T>)\n}\n\nfunction ConnectButton() {\n    const bus = useBus()\n    const connected = useChange(bus, (_) => _.connected)\n    const services = useServices({ serviceClass: SRV_ACCELEROMETER })\n    const [streaming, setStreaming] = useState(false)\n    const [xSink, setXSink] = useState<DataSink>()\n    const [ySink, setYSink] = useState<DataSink>()\n    const [zSink, setZSink] = useState<DataSink>()\n    const [xAxisStream, setXAxisStream] = useState<Subject<Datum>>()\n    const [yAxisStream, setYAxisStream] = useState<Subject<Datum>>()\n    const [zAxisStream, setZAxisStream] = useState<Subject<Datum>>()\n\n    useEffect(() => {\n        if (!inIFrame() && window.location.hash === '#dbg') startDevTools()\n    }, [])\n\n    // register for accelerometer data events\n    useEffect(() => {\n        if (!services || services.length === 0) return\n        const accelService = services[0]\n\n        console.log(accelService.specification)\n        const unsubs = accelService.readingRegister.subscribe(\n            REPORT_UPDATE,\n            // don't trigger more than every 100ms\n            throttle(async () => {\n                if (!streaming || !xSink || !ySink || !zSink) return\n                const [x, y, z] = accelService.readingRegister.unpackedValue\n                console.log('vpotluri: calling PushPoint.')\n                if (xSink && xAxisStream) xAxisStream.next(new Datum(xSink.id, x))\n                // if(ySink && yAxisStream) yAxisStream.next(new Datum(ySink.id,y))\n                // if(zSink && zAxisStream) zAxisStream.next(new Datum(zSink.id,z))\n                // OutputEngine.getInstance().pushPoint(x, sink.id)\n            }, TONE_THROTTLE),\n        )\n\n        // cleanup callback\n        return () => unsubs?.()\n    }, [services])\n\n    const handleConnect = async () => {\n        if (connected) {\n            console.log('DISCONNECT')\n            await bus.disconnect()\n        } else {\n            console.log('connect')\n            await bus.connect()\n        }\n    }\n\n    const handleStartStreaming = () => {\n        console.log('entering handel stream')\n        let xSinkID: number = 0\n        let ySinkID: number = 1\n        let zSinkID: number = 2\n        let srcX = xSink\n        let srcY = ySink\n        let srcZ = zSink\n        if (!streaming) {\n            console.log('streaming was false')\n            /**\n             * check if a sink exists to stream X axis data to. else create one.\n             */\n            if (!srcX) {\n                srcX = OutputEngine.getInstance().addSink('jacdac accelerometer X axis')\n                console.log(`added sink to stream x axis data ${xSink}`)\n                srcX.addDataHandler(new NoteHandler([-1, 1], new NoteSonify(-1)))\n                // src.addDataHandler(new FilterRangeHandler([-1, 0], new NoiseSonify()))\n                // dummy stats. Do we know the min and max for accelerometer?\n                //max:\n                // srcX.addDataHandler(new RunningExtremaHandler(-1, new Speech()))\n                //slope for min\n                srcX.addDataHandler(new SlopeParityHandler(-1, new Speech()))\n                //min\n                // srcX.addDataHandler(new RunningExtremaHandler(1, new Speech()))\n                xSinkID = srcX.id\n                setXSink(srcX)\n            }\n\n            /**\n             * check if a sink exists to stream Y axis data to. else create one.\n             */\n            if (!srcY) {\n                srcY = OutputEngine.getInstance().addSink('jacdac accelerometer Y axis')\n                console.log(`added sink to stream y axis data ${ySink}`)\n                srcY.addDataHandler(new NoteHandler([-1, 1], new NoteSonify(1)))\n                // src.addDataHandler(new FilterRangeHandler([-1, 0], new NoiseSonify()))\n                // dummy stats. Do we know the min and max for accelerometer?\n                ySinkID = srcY.id\n                setYSink(srcY)\n            }\n\n            /**\n             * check if a sink exists to stream Z axis data to. else create one.\n             */\n            if (!srcZ) {\n                srcZ = OutputEngine.getInstance().addSink('jacdac accelerometer Z axis')\n                console.log(`added sink to stream z axis data ${zSink}`)\n                // srcZ.addDataHandler(new NoteHandler([-1,1], new NoteSonify(0)))\n                // src.addDataHandler(new FilterRangeHandler([-1, 0], new NoiseSonify()))\n                // dummy stats. Do we know the min and max for accelerometer?\n                //max:\n                // srcZ.addDataHandler(new RunningExtremaHandler(1, new Speech()))\n                //min\n                // srcZ.addDataHandler(new RunningExtremaHandler(1, new Speech()))\n                zSinkID = srcZ.id\n                setZSink(srcZ)\n            }\n            /**\n             * check if a observable exists for each of the axes.\n             * If not, create an RXJS Subject, filter out null values and change it to be typed as observable<datum>, and then set this as a stream for the source.\n             */\n\n            let sourceX = xAxisStream\n            if (!sourceX) {\n                sourceX = new Subject<Datum>()\n                setXAxisStream(sourceX)\n                OutputEngine.getInstance().setStream(xSinkID, sourceX.pipe(filterNullish()))\n            }\n\n            let sourceY = yAxisStream\n            if (!sourceY) {\n                sourceY = new Subject<Datum>()\n                setYAxisStream(sourceY)\n                OutputEngine.getInstance().setStream(ySinkID, sourceY.pipe(filterNullish()))\n            }\n\n            let sourceZ = zAxisStream\n            if (!sourceZ) {\n                sourceZ = new Subject<Datum>()\n                setZAxisStream(sourceZ)\n                OutputEngine.getInstance().setStream(zSinkID, sourceZ.pipe(filterNullish()))\n            }\n\n            OutputEngine.getInstance().next(OutputStateChange.Play)\n        } else {\n            OutputEngine.getInstance().next(OutputStateChange.Stop)\n        }\n\n        setStreaming(!streaming)\n    }\n\n    return (\n        <>\n            <Button onClick={handleConnect}>{bus?.connected ? 'Disconnect' : 'Connect'}</Button>\n            {bus && (\n                <Button onClick={handleStartStreaming} disabled={services.length === 0}>\n                    {streaming ? 'Stop streaming' : 'Start streaming'}\n                </Button>\n            )}\n        </>\n    )\n}\n\nexport default function Page() {\n    return (\n        <JacdacProvider initialBus={bus}>\n            <ConnectButton />\n        </JacdacProvider>\n    )\n}\n"],"sourceRoot":""}