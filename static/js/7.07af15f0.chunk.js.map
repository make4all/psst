{"version":3,"sources":["bus.ts","pages/MicrobitController.tsx"],"names":["bus","createWebBus","filterNullish","pipe","filter","x","MicroBitButton","props","service","outputEngine","downEvent","useEvent","ButtonEvent","Down","upEvent","Up","useState","instanceName","setInstanceName","state","setState","handleButton","id","down","value","OutputStateChange","Play","next","Stop","useEffect","subscribe","EVENT","resolveIName","a","resolveInstanceName","friendlyName","ConnectButton","useBus","connected","useChange","_","services","useServices","serviceClass","SRV_ACCELEROMETER","buttons","SRV_BUTTON","streaming","setStreaming","xSink","setXSink","ySink","setYSink","zSink","setZSink","xAxisStream","setXAxisStream","yAxisStream","setYAxisStream","zAxisStream","setZAxisStream","inIFrame","window","location","hash","startDevTools","length","accelService","unsubs","readingRegister","REPORT_UPDATE","throttle","unpackedValue","console","log","Datum","OutputEngine","getInstance","e","unsubscribe","handleConnect","disconnect","connect","onClick","xSinkID","ySinkID","zSinkID","srcX","srcY","srcZ","addSink","addDataHandler","NoteHandler","NoteSonify","SlopeParityHandler","Speech","sourceX","Subject","setStream","sourceY","sourceZ","disabled","map","button","i","Page","initialBus"],"mappings":"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","file":"static/js/7.07af15f0.chunk.js","sourcesContent":["import { createWebBus } from 'jacdac-ts'\n\nexport const bus = createWebBus()\n","import React, { FC, useState, useEffect } from 'react'\n// import ConnectButton from \"../../jacdac-docs/src/components/buttons/ConnectButton\"\n\n// import { JDBus } from \"jacdac-ts/src/jdom/bus\"\n\nimport {\n    SRV_ACCELEROMETER,\n    REPORT_UPDATE,\n    throttle,\n    startDevTools,\n    inIFrame,\n    SRV_BUTTON,\n    EVENT,\n    ButtonEvent,\n    JDService,\n} from 'jacdac-ts'\nimport { useServices, useChange, useBus, useEvent } from 'react-jacdac'\nimport { Button } from '@mui/material'\nimport { OutputEngine } from '../sonification/OutputEngine'\nimport { JacdacProvider } from 'react-jacdac'\nimport { bus } from '../bus'\nimport { DataSink } from '../sonification/DataSink'\nimport { NoteHandler } from '../sonification/handler/NoteHandler'\nimport { OutputStateChange } from '../sonification/OutputConstants'\nimport { filter, Observable, OperatorFunction, pipe, Subject, UnaryFunction } from 'rxjs'\nimport { Datum } from '../sonification/Datum'\nimport { RunningExtremaHandler } from '../sonification/handler/RunningExtremaHandler'\nimport { SlopeParityHandler } from '../sonification/handler/SlopeParityHandler'\nimport { Speech } from '../sonification/output/Speech'\nimport { SettingsInputAntennaTwoTone } from '@mui/icons-material'\nimport { NoteSonify } from '../sonification/output/NoteSonify'\n\nconst TONE_THROTTLE = 100\n\n/**\n * helper function to filter out null values from subjects, and create an observable<Datum> for the sink to subscribe.\n * Source: https://stackoverflow.com/questions/57999777/filter-undefined-from-rxjs-observable\n * @returns observable <datum>\n */\n\nfunction filterNullish<T>(): UnaryFunction<Observable<T | null | undefined>, Observable<T>> {\n    return pipe(filter((x) => x != null) as OperatorFunction<T | null | undefined, T>)\n}\n\nfunction MicroBitButton(props: {outputEngine: OutputEngine, service: JDService}) {\n    const { service, outputEngine } = props\n    const downEvent = useEvent(service, ButtonEvent.Down)\n    const upEvent = useEvent(service, ButtonEvent.Up)\n\n    const [instanceName, setInstanceName] = useState('')\n    const [state, setState] = useState('up')\n\n    // id corresponds to button functionality\n    const handleButton = (id: string, down: boolean) => {\n        // only act on an up event\n\n        if (down)\n            setState(\"down\")\n        else\n            setState(\"up\")\n\n        if (down) return\n\n        if (id === \"A+B\") {\n            if (outputEngine.value === OutputStateChange.Play)\n                outputEngine.next(OutputStateChange.Stop)\n            else\n                outputEngine.next(OutputStateChange.Play)\n        }\n    }\n    useEffect(() => {\n        if (instanceName === \"\") return\n        downEvent.subscribe(EVENT, () => handleButton(instanceName, true))\n    }, [downEvent, instanceName])\n    useEffect(() =>{\n        if (instanceName === \"\") return\n        upEvent.subscribe(EVENT, () => handleButton(instanceName, false))\n    }, [upEvent, instanceName])\n\n    useEffect(() => {\n        const resolveIName = async () => setInstanceName(await service.resolveInstanceName())\n        resolveIName()\n    }, [])\n    return (<div key={service.friendlyName}><br/><>{instanceName} {state}</></div>)\n}\n\nfunction ConnectButton() {\n    const bus = useBus()\n    const connected = useChange(bus, (_) => _.connected)\n    const services = useServices({ serviceClass: SRV_ACCELEROMETER })\n    const buttons = useServices({ serviceClass: SRV_BUTTON })\n    const [streaming, setStreaming] = useState(false)\n    const [xSink, setXSink] = useState<DataSink>()\n    const [ySink, setYSink] = useState<DataSink>()\n    const [zSink, setZSink] = useState<DataSink>()\n    const [xAxisStream, setXAxisStream] = useState<Subject<Datum>>()\n    const [yAxisStream, setYAxisStream] = useState<Subject<Datum>>()\n    const [zAxisStream, setZAxisStream] = useState<Subject<Datum>>()\n\n    useEffect(() => {\n        if (!inIFrame() && window.location.hash === '#dbg') startDevTools()\n    }, [])\n\n    // register for accelerometer data events\n    useEffect(() => {\n        if (!services || services.length === 0) return\n        const accelService = services[0]\n        const unsubs = accelService.readingRegister.subscribe(\n            REPORT_UPDATE,\n            // don't trigger more than every 100ms\n            throttle(async () => {\n                if (!streaming || !xSink || !ySink || !zSink) return\n                const [x, y, z] = accelService.readingRegister.unpackedValue\n                console.log('vpotluri: calling PushPoint.')\n                if (xSink && xAxisStream) xAxisStream.next(new Datum(xSink.id, x))\n                // if(ySink && yAxisStream) yAxisStream.next(new Datum(ySink.id,y))\n                // if(zSink && zAxisStream) zAxisStream.next(new Datum(zSink.id,z))\n                // OutputEngine.getInstance().pushPoint(x, sink.id)\n            }, TONE_THROTTLE),\n        )\n\n        // cleanup callback\n        return () => unsubs?.()\n    }, [services])\n\n    useEffect(()=>{\n        OutputEngine.getInstance().subscribe((e: OutputStateChange)=>{\n            console.log(\"Chaning streaming state \", e)\n            if (e === OutputStateChange.Play) \n                setStreaming(true);\n            else \n                setStreaming(false);\n        })\n        return () => OutputEngine.getInstance().unsubscribe()\n    }, [])\n\n    const handleConnect = async () => {\n        if (connected) {\n            console.log('DISCONNECT')\n            await bus.disconnect()\n        } else {\n            console.log('connect')\n            await bus.connect()\n        }\n    }\n\n    const handleStartStreaming = () => {\n        console.log('entering handel stream')\n        let xSinkID: number = 0\n        let ySinkID: number = 1\n        let zSinkID: number = 2\n        let srcX = xSink\n        let srcY = ySink\n        let srcZ = zSink\n        if (OutputEngine.getInstance().value !== OutputStateChange.Play) {\n            console.log('streaming was false')\n            /**\n             * check if a sink exists to stream X axis data to. else create one.\n             */\n            if (!srcX) {\n                srcX = OutputEngine.getInstance().addSink('jacdac accelerometer X axis')\n                console.log(`added sink to stream x axis data ${xSink}`)\n                srcX.addDataHandler(new NoteHandler([-1, 1], new NoteSonify(-1)))\n                // src.addDataHandler(new FilterRangeHandler([-1, 0], new NoiseSonify()))\n                // dummy stats. Do we know the min and max for accelerometer?\n                //max:\n                // srcX.addDataHandler(new RunningExtremaHandler(-1, new Speech()))\n                //slope for min\n                srcX.addDataHandler(new SlopeParityHandler(-1, new Speech()))\n                //min\n                // srcX.addDataHandler(new RunningExtremaHandler(1, new Speech()))\n                xSinkID = srcX.id\n                setXSink(srcX)\n            }\n\n            /**\n             * check if a sink exists to stream Y axis data to. else create one.\n             */\n            if (!srcY) {\n                srcY = OutputEngine.getInstance().addSink('jacdac accelerometer Y axis')\n                console.log(`added sink to stream y axis data ${ySink}`)\n                srcY.addDataHandler(new NoteHandler([-1, 1], new NoteSonify(1)))\n                // src.addDataHandler(new FilterRangeHandler([-1, 0], new NoiseSonify()))\n                // dummy stats. Do we know the min and max for accelerometer?\n                ySinkID = srcY.id\n                setYSink(srcY)\n            }\n\n            /**\n             * check if a sink exists to stream Z axis data to. else create one.\n             */\n            if (!srcZ) {\n                srcZ = OutputEngine.getInstance().addSink('jacdac accelerometer Z axis')\n                console.log(`added sink to stream z axis data ${zSink}`)\n                // srcZ.addDataHandler(new NoteHandler([-1,1], NoteSonify(0)))\n                // src.addDataHandler(new FilterRangeHandler([-1, 0], new NoiseSonify()))\n                // dummy stats. Do we know the min and max for accelerometer?\n                //max:\n                // srcZ.addDataHandler(new RunningExtremaHandler(1, new Speech()))\n                //min\n                // srcZ.addDataHandler(new RunningExtremaHandler(1, new Speech()))\n                zSinkID = srcZ.id\n                setZSink(srcZ)\n            }\n            /**\n             * check if a observable exists for each of the axes.\n             * If not, create an RXJS Subject, filter out null values and change it to be typed as observable<datum>, and then set this as a stream for the source.\n             */\n\n            let sourceX = xAxisStream\n            if (!sourceX) {\n                sourceX = new Subject<Datum>()\n                setXAxisStream(sourceX)\n                OutputEngine.getInstance().setStream(xSinkID, sourceX.pipe(filterNullish()))\n            }\n\n            let sourceY = yAxisStream\n            if (!sourceY) {\n                sourceY = new Subject<Datum>()\n                setYAxisStream(sourceY)\n                OutputEngine.getInstance().setStream(ySinkID, sourceY.pipe(filterNullish()))\n            }\n\n            let sourceZ = zAxisStream\n            if (!sourceZ) {\n                sourceZ = new Subject<Datum>()\n                setZAxisStream(sourceZ)\n                OutputEngine.getInstance().setStream(zSinkID, sourceZ.pipe(filterNullish()))\n            }\n\n            OutputEngine.getInstance().next(OutputStateChange.Play)\n        } else {\n            OutputEngine.getInstance().next(OutputStateChange.Stop)\n        }\n    }\n\n    console.log(\"STREAMING STATE: \", streaming)\n\n    return (\n        <>\n            <Button onClick={handleConnect}>{bus?.connected ? 'Disconnect' : 'Connect'}</Button>\n            {bus && (\n                <Button onClick={handleStartStreaming} disabled={services.length === 0}>\n                    {streaming ? 'Stop streaming' : 'Start streaming'}\n                </Button>\n            )}\n            {buttons &&\n                buttons.map((button,i) => <MicroBitButton key={i} service={button} outputEngine={OutputEngine.getInstance()}/>)}\n        </>\n    )\n}\n\nexport default function Page() {\n    return (\n        <JacdacProvider initialBus={bus}>\n            <ConnectButton />\n        </JacdacProvider>\n    )\n}\n"],"sourceRoot":""}